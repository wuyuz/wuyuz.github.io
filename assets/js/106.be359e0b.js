(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{451:function(t,_,v){"use strict";v.r(_);var a=v(42),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"http和https协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http和https协议"}},[t._v("#")]),t._v(" HTTP和HTTPS协议")]),t._v(" "),v("h2",{attrs:{id:"http协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http协议"}},[t._v("#")]),t._v(" HTTP协议")]),t._v(" "),v("h5",{attrs:{id:"_1-官方概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-官方概念"}},[t._v("#")]),t._v(" 1.官方概念：")]),t._v(" "),v("p",[t._v("HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）"),v("strong",[t._v("服务器传输超文本到本地浏览器的传送协议")]),t._v("。（虽然童鞋们将这条概念都看烂了，但是也没办法，毕竟这就是HTTP的权威官方的概念解释，要想彻底理解，请客观目移下侧......）")]),t._v(" "),v("h5",{attrs:{id:"_2-白话概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-白话概念"}},[t._v("#")]),t._v(" 2.白话概念：")]),t._v(" "),v("p",[v("strong",[t._v("HTTP协议就是服务器（Server）和客户端（Client）之间进行数据交互（相互传输数据）的一种形式")]),t._v("。我们可以将Server和Client进行拟人化，那么该协议就是Server和Client这两兄弟间指定的一种交互沟通方式。大家都看过智取威虎山中杨子荣和土匪们之间说的黑话吧：(双方约定好的合同，交互方式)")]),t._v(" "),v("ul",[v("li",[v("p",[t._v('土匪："天王盖地虎！"')])]),t._v(" "),v("li",[v("p",[t._v('座山雕："宝塔镇河妖!"')])])]),t._v(" "),v("p",[v("strong",[t._v("3.HTTP工作原理：")])]),t._v(" "),v("p",[t._v("HTTP协议工作于客户端 - 服务端架构之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。那么可以理解浏览器就是信息传递的载体，除了浏览器我们的程序也可以放送请求，那么程序也是一种请求载体")]),t._v(" "),v("h5",{attrs:{id:"_4-http四点注意事项"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-http四点注意事项"}},[t._v("#")]),t._v(" 4.HTTP四点注意事项：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("HTTP是无连接")]),t._v("：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。")]),t._v(" "),v("li",[t._v("HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。")]),t._v(" "),v("li",[t._v("HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。")])])])]),t._v(" "),v("h5",{attrs:{id:"_5-http之url"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-http之url"}},[t._v("#")]),t._v(" 5.HTTP之URL：")]),t._v(" "),v("p",[v("strong",[t._v("HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息")])]),t._v(" "),v("p",[t._v("​\t\t\tURL,全称是UniformResourceLocator, 中文叫"),v("strong",[t._v("统一资源定位符")]),t._v(",是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name，从上面的URL可以看出，一个完整的URL包括以下几部分：")]),t._v(" "),v("ul",[v("li",[t._v('协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP，ws等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符')]),t._v(" "),v("li",[v("strong",[t._v("域名部分")]),t._v("：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用\n- 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口\n- "),v("strong",[t._v("虚拟目录部分")]),t._v("：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”\n- "),v("strong",[t._v("文件名部分")]),t._v("：从域名后的"),v("strong",[t._v("最后一个“/”开始到“？”为止")]),t._v("，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名\n- 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分\n- 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。")])]),t._v(" "),v("p"),t._v(" "),v("h5",{attrs:{id:"_6-http之request"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-http之request"}},[t._v("#")]),t._v(" 6.HTTP之Request：")]),t._v(" "),v("p",[t._v("​\t"),v("em",[t._v("客户端发送一个HTTP请求到服务器的请求消息包括以下组成部分：")]),t._v("\n**报文头：**常被叫做请求头，请求头中存储的是该请求的一些主要说明（自我介绍）。服务器据此获取客户端的信息。"),v("strong",[t._v("报文体：常被叫做请求体，请求体中存储的是将要传输/发送给服务器的数据信息。")])]),t._v(" "),v("h5",{attrs:{id:"常见的请求头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的请求头"}},[t._v("#")]),t._v(" 常见的请求头：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("accept:浏览器通过这个头告诉服务器，它所支持的数据类型")])]),t._v(" "),v("li",[v("p",[t._v("Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集")])]),t._v(" "),v("li",[v("p",[t._v("Accept-Encoding：浏览器通过这个头告诉服务器，支持的压缩格式")])]),t._v(" "),v("li",[v("p",[t._v("Accept-Language：浏览器通过这个头告诉服务器，它的语言环境")])]),t._v(" "),v("li",[v("p",[t._v("Host：浏览器通过这个头告诉服务器，想访问哪台主机")])]),t._v(" "),v("li",[v("p",[t._v("If-Modified-Since: 浏览器通过这个头告诉服务器，缓存数据的时间")])]),t._v(" "),v("li",[v("p",[t._v("Referer：浏览器通过这个头告诉服务器，客户机是哪个页面来的 防盗链")])]),t._v(" "),v("li",[v("p",[t._v("Connection：浏览器通过这个头告诉服务器，请求完后是断开链接还是何链接, 可设置为 keep-alive/close")])]),t._v(" "),v("li",[v("p",[t._v("X-Requested-With: XMLHttpRequest 代表通过ajax方式进行访问*")])]),t._v(" "),v("li",[v("p",[v("em",[t._v("User-Agent：请求载体的身份标识")])])])]),t._v(" "),v("h5",{attrs:{id:"_7-http之response"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-http之response"}},[t._v("#")]),t._v(" 7.HTTP之Response：")]),t._v(" "),v("p",[t._v("服务器回传"),v("em",[t._v("一个HTTP响应到客户端的响应消息包括以下组成部分：")])]),t._v(" "),v("h5",{attrs:{id:"http的响应状态码由5段组成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http的响应状态码由5段组成"}},[t._v("#")]),t._v(" HTTP的响应状态码由5段组成：")]),t._v(" "),v("ul",[v("li",[v("ul",[v("li",[t._v("1xx : 一般是告诉客户端，请求已经收到了，正在处理，别急...")])])]),t._v(" "),v("li",[v("ul",[v("li",[t._v("2xx :  处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息.")])])]),t._v(" "),v("li",[v("ul",[v("li",[t._v("3xx :  重定向到其它地方。它让客户端再发起一个请求以完成整个处理。")])])]),t._v(" "),v("li",[v("ul",[v("li",[t._v("4xx :  处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。")])])]),t._v(" "),v("li",[v("ul",[v("li",[t._v("5xx :  处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。")])])]),t._v(" "),v("li")]),t._v(" "),v("p",[v("strong",[t._v("常见的相应头信息")]),t._v("：相应体：根据客户端指定的请求信息，发送给客户端的指定数据")]),t._v(" "),v("ul",[v("li",[t._v("Location: 服务器通过这个头，来告诉浏览器跳到哪里")]),t._v(" "),v("li",[t._v("Server：服务器通过这个头，告诉浏览器服务器的型号")]),t._v(" "),v("li",[t._v("Content-Encoding：服务器通过这个头，告诉浏览器，数据的压缩格式")]),t._v(" "),v("li",[t._v("Content-Length: 服务器通过这个头，告诉浏览器回送数据的长度")]),t._v(" "),v("li",[t._v("Content-Language: 服务器通过这个头，告诉浏览器语言环境")]),t._v(" "),v("li",[t._v("Content-Type：服务器通过这个头，告诉浏览器回送数据的类型")]),t._v(" "),v("li",[t._v("Refresh：服务器通过这个头，告诉浏览器定时刷新")]),t._v(" "),v("li",[t._v("Content-Disposition: 服务器通过这个头，告诉浏览器以下载方式打数据")]),t._v(" "),v("li",[t._v("Transfer-Encoding：服务器通过这个头，告诉浏览器数据是以分块方式回送的")]),t._v(" "),v("li",[t._v("Expires: -1 控制浏览器不要缓存")]),t._v(" "),v("li",[t._v("Cache-Control: no-cache")]),t._v(" "),v("li",[t._v("Pragma: no-cache")])]),t._v(" "),v("p"),t._v(" "),v("h2",{attrs:{id:"https协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https协议"}},[t._v("#")]),t._v(" HTTPS协议")]),t._v(" "),v("h5",{attrs:{id:"_1-官方概念-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-官方概念-2"}},[t._v("#")]),t._v(" 1.官方概念：")]),t._v(" "),v("p",[t._v("HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。")]),t._v(" "),v("h5",{attrs:{id:"_2-白话概念-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-白话概念-2"}},[t._v("#")]),t._v(" 2.白话概念：")]),t._v(" "),v("p",[t._v("加密安全版的HTTP协议。")]),t._v(" "),v("h5",{attrs:{id:"公钥与私钥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#公钥与私钥"}},[t._v("#")]),t._v(" 公钥与私钥：")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("公钥")]),t._v("加密 ：")]),t._v(" "),v("p",[t._v("​      假设一下，我找了两个数字(真实是随机数)，一个是1，一个是2。我喜欢2这个数字，就保留起来，不告诉你们(作为私钥），然后我告诉大家，1是我的公钥。")]),t._v(" "),v("p",[t._v("我有一个文件，不能让别人看，我就用1加密了。别人找到了这个文件，但是他不知道2就是解密的私钥啊，所以他解不开，只有我可以用 数字2，就是我的私钥，来解密。这样我就可以保护数据了。")]),t._v(" "),v("p",[t._v("​      我的好朋友'xxx'用我的公钥1加密了字符a（提前发给他公钥），他用发过去的公钥加密后成了b，放在网上。别人偷到了这个文件，但是别人解不开，因为别人不知道我的私钥2， 只有我的私钥才能解密，解密后就得到a。这样，我们就可以传送加密的数据了。（ "),v("strong",[t._v("朋友 --\x3e  我 数据传输安全")]),t._v("）")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("私钥")]),t._v("签名：")]),t._v(" "),v("p",[t._v("​     如果我用"),v("strong",[t._v("私钥加密一段数据")]),t._v("（当然只有我可以用私钥加密，因为只有我知道2是我的私钥），结果所有的人都看到我的内容了，因为他们只知道我的公钥是1，并不能解密，那么这种加密有什么用处呢？")]),t._v(" "),v("p",[t._v("但是如果我的好朋友'xxx'说有人冒充我给他发信。怎么办呢？我把我要发的信息，内容c，用我的私钥2加密，加密后的内容是d，发给xxx，再告诉他解密看是不是c？他用我的公钥1解密，发现果然是c。 这个时候，他会想到，能够用我的公钥解密的数据，必然是用我的私钥加的密。只有我知道我得私钥，因此他就可以确认确实是我发的东西。 这样我们就能确认发送方身份了。这个过程叫做数字签名。当然具体的过程要稍微复杂一些。用私钥来加密数据，用途就是"),v("strong",[t._v("数字签名")]),t._v("。")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("知识点复习：公钥和私钥是成对的，它们互相解密。\n     公钥加密，私钥解密。\n     私钥数字签名，公钥验证。\n")])])])])]),t._v(" "),v("h4",{attrs:{id:"三种加密方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三种加密方式"}},[t._v("#")]),t._v(" 三种加密方式：")]),t._v(" "),v("ul",[v("li",[v("h5",{attrs:{id:"ssl加密技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ssl加密技术"}},[t._v("#")]),t._v(" SSL加密技术")]),t._v(" "),v("p",[t._v("​\tSSL采用的加密技术叫做“共享密钥加密”，也叫作“对称密钥加密”，这种加密方法是这样的，比如客户端向服务器发送一条信息，首先客户端会采用已知的算法对信息进行加密，比如MD5或者Base64加密，接收端对加密的信息进行解密的时候需要用到密钥，中间会传递密钥，（加密和解密的密钥是同一个），密钥在传输中间是被加密的。这种方式看起来安全(传出去的是公钥，"),v("strong",[t._v("“公加私解”")]),t._v(")，但是仍有潜在的危险，一旦被窃听，或者信息被挟持，就有可能破解密钥，而破解其中的信息。因此“共享密钥加密”这种方式存在安全隐患：")])]),t._v(" "),v("li",[v("h5",{attrs:{id:"非对称秘钥加密技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非对称秘钥加密技术"}},[t._v("#")]),t._v(" 非对称秘钥加密技术")]),t._v(" "),v("p",[t._v("“非对称加密”使用的时候有两把锁，一把叫做“私有密钥”，一把是“公开密钥”，使用非对象加密的加密方式的时候，服务器首先告诉客户端按照自己给定的公开密钥进行加密处理，客户端按照公开密钥加密以后，服务器接受到信息再通过自己的私有密钥进行解密，这样做的好处就是解密的钥匙根本就不会进行传输，因此也就避免了被挟持的风险。就算公开密钥被窃听者拿到了，它也很难进行解密，因为解密过程是对离散对数求值，这可不是轻而易举就能做到的事。以下是非对称加密的原理图：")])])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("非对称秘钥加密技术也存在如下缺点：\n　　第一个是：如何保证接收端向发送端发出公开秘钥的时候，发送端确保收到的是预先要发送的，而不会被挟持。只要是发送密钥，就有可能有被挟持的风险。\n\n　　第二个是：非对称加密的方式效率比较低，它处理起来更为复杂，通信过程中使用就有一定的效率问题而影响通信速度\n")])])]),v("ul",[v("li",[v("h5",{attrs:{id:"https的证书机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https的证书机制"}},[t._v("#")]),t._v(" https的证书机制")]),t._v(" "),v("p",[t._v("​      在上面我们讲了非对称加密的缺点，其中第一个就是公钥很可能存在被挟持的情况，无法保证客户端收到的公开密钥就是服务器发行的公开密钥。此时就引出了公开密钥证书机制。数字证书认证机构是客户端与服务器都可信赖的第三方机构。证书的具体传播过程如下：")]),t._v(" "),v("ul",[v("li",[t._v("服务器的开发者携带公开密钥，向数字证书认证机构提出公开密钥的申请，数字证书认证机构在认清申请者的身份，审核通过以后，会对开发者申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将密钥放在证书里面，绑定在一起")])]),t._v(" "),v("p",[t._v("服务器将这份数字证书发送给客户端，因为客户端也认可证书机构，客户端可以通过数字证书中的数字签名来验证公钥的真伪，来确保服务器传过来的公开密钥是真实的。一般情况下，证书的数字签名是很难被伪造的，这取决于认证机构的公信力。一旦确认信息无误之后，客户端就会通过公钥对报文进行加密发送，服务器接收到以后用自己的私钥进行解密。")])])])])}),[],!1,null,null,null);_.default=s.exports}}]);