(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{355:function(n,t,e){"use strict";e.r(t);var a=e(42),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"c-核心编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-核心编程"}},[n._v("#")]),n._v(" C++核心编程")]),n._v(" "),e("p",[n._v("本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。")]),n._v(" "),e("h2",{attrs:{id:"_1-内存分区模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存分区模型"}},[n._v("#")]),n._v(" 1 内存分区模型")]),n._v(" "),e("p",[n._v("C++程序在执行时，将内存大方向划分为"),e("strong",[n._v("4个区域")])]),n._v(" "),e("ul",[e("li",[n._v("代码区：存放函数体的二进制代码，由操作系统进行管理的")]),n._v(" "),e("li",[n._v("全局区：存放全局变量和静态变量以及常量")]),n._v(" "),e("li",[n._v("栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等")]),n._v(" "),e("li",[n._v("堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收")])]),n._v(" "),e("p",[e("strong",[n._v("内存四区意义：")])]),n._v(" "),e("p",[n._v("不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程")]),n._v(" "),e("h3",{attrs:{id:"_1-1-程序运行前"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-程序运行前"}},[n._v("#")]),n._v(" 1.1 程序运行前")]),n._v(" "),e("p",[n._v("​\t在程序编译后，生成了exe可执行程序，"),e("strong",[n._v("未执行该程序前")]),n._v("分为两个区域")]),n._v(" "),e("p",[n._v("​\t"),e("strong",[n._v("代码区：")])]),n._v(" "),e("p",[n._v("​\t\t存放 CPU 执行的机器指令")]),n._v(" "),e("p",[n._v("​\t\t代码区是"),e("strong",[n._v("共享")]),n._v("的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可")]),n._v(" "),e("p",[n._v("​\t\t代码区是"),e("strong",[n._v("只读")]),n._v("的，使其只读的原因是防止程序意外地修改了它的指令")]),n._v(" "),e("p",[n._v("​\t"),e("strong",[n._v("全局区：")])]),n._v(" "),e("p",[n._v("​\t\t全局变量和静态变量存放在此.")]),n._v(" "),e("p",[n._v("​\t\t全局区还包含了常量区, 字符串常量和其他常量也存放在此.")]),n._v(" "),e("p",[n._v("​\t\t==该区域的数据在程序结束后由操作系统释放==.")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//全局变量\nint g_a = 10;\nint g_b = 10;\n\n//全局常量\nconst int c_g_a = 10;\nconst int c_g_b = 10;\n\nint main() {\n\n\t//局部变量\n\tint a = 10;\n\tint b = 10;\n\n\t//打印地址\n\tcout << "局部变量a地址为： " << (int)&a << endl;\n\tcout << "局部变量b地址为： " << (int)&b << endl;\n\n\tcout << "全局变量g_a地址为： " <<  (int)&g_a << endl;\n\tcout << "全局变量g_b地址为： " <<  (int)&g_b << endl;\n\n\t//静态变量\n\tstatic int s_a = 10;\n\tstatic int s_b = 10;\n\n\tcout << "静态变量s_a地址为： " << (int)&s_a << endl;\n\tcout << "静态变量s_b地址为： " << (int)&s_b << endl;\n\n\tcout << "字符串常量地址为： " << (int)&"hello world" << endl;\n\tcout << "字符串常量地址为： " << (int)&"hello world1" << endl;\n\n\tcout << "全局常量c_g_a地址为： " << (int)&c_g_a << endl;\n\tcout << "全局常量c_g_b地址为： " << (int)&c_g_b << endl;\n\n\tconst int c_l_a = 10;\n\tconst int c_l_b = 10;\n\tcout << "局部常量c_l_a地址为： " << (int)&c_l_a << endl;\n\tcout << "局部常量c_l_b地址为： " << (int)&c_l_b << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("打印结果：")]),n._v(" "),e("p",[e("img",{attrs:{src:"assets/1545017602518.png",alt:"1545017602518"}})]),n._v(" "),e("p",[n._v("总结：")]),n._v(" "),e("ul",[e("li",[n._v("C++中在程序运行前分为全局区和代码区")]),n._v(" "),e("li",[n._v("代码区特点是共享和只读")]),n._v(" "),e("li",[n._v("全局区中存放全局变量、静态变量、常量")]),n._v(" "),e("li",[n._v("常量区中存放 const修饰的全局常量  和 字符串常量")])]),n._v(" "),e("h3",{attrs:{id:"_1-2-程序运行后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-程序运行后"}},[n._v("#")]),n._v(" 1.2 程序运行后")]),n._v(" "),e("p",[n._v("​\t"),e("strong",[n._v("栈区：")])]),n._v(" "),e("p",[n._v("​\t\t由编译器自动分配释放, 存放函数的参数值,局部变量等")]),n._v(" "),e("p",[n._v("​\t\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('int * func()\n{\n\tint a = 10;\n\treturn &a;  // 局部变量存放在栈区，栈区的数据在函数执行完后会销毁，但是这里却返回，语法通过，但是数据是错误的\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;  // 10 ，第一次编译器帮我们做了保留，\n\tcout << *p << endl;  // 29341，第二次就是一个乱数据\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("​\t"),e("strong",[n._v("堆区：")])]),n._v(" "),e("p",[n._v("​\t\t由程序员分配释放,若程序员不释放,程序结束时由操作系统回收")]),n._v(" "),e("p",[n._v("​\t\t在C++中主要利用new在堆区开辟内存")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('int* func()\n{\n\tint* a = new int(10); // 通过new来创建堆区数据\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n    \n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[e("strong",[n._v("总结：")])]),n._v(" "),e("p",[n._v("堆区数据由程序员管理开辟和释放")]),n._v(" "),e("p",[n._v("堆区数据利用new关键字进行开辟内存")]),n._v(" "),e("h3",{attrs:{id:"_1-3-new操作符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-new操作符"}},[n._v("#")]),n._v(" 1.3 new操作符")]),n._v(" "),e("p",[n._v("​\tC++中利用==new==操作符在堆区开辟数据")]),n._v(" "),e("p",[n._v("​\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==")]),n._v(" "),e("p",[n._v("​\t语法："),e("code",[n._v("new 数据类型")])]),n._v(" "),e("p",[n._v("​\t利用new创建的数据，会返回该数据对应的类型的指针")]),n._v(" "),e("p",[e("strong",[n._v("示例1： 基本语法")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('int* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\t//利用delete释放堆区数据\n\tdelete p;\n\t//cout << *p << endl; //报错，释放的空间不可访问\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[e("strong",[n._v("示例2：开辟数组")])]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//堆区开辟数组\nint main() {\n\n\tint* arr = new int[10];\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tarr[i] = i + 100;\n\t}\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << arr[i] << endl;\n\t}\n\t//释放数组 delete 后加 []\n\tdelete[] arr;\n\n\tsystem("pause");\n\treturn 0;\n}\n\n')])])]),e("h2",{attrs:{id:"_2-引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-引用"}},[n._v("#")]),n._v(" 2 引用")]),n._v(" "),e("h3",{attrs:{id:"_2-1-引用的基本使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-引用的基本使用"}},[n._v("#")]),n._v(" 2.1 引用的基本使用")]),n._v(" "),e("p",[n._v("**作用： **给变量起别名")]),n._v(" "),e("p",[e("strong",[n._v("语法：")]),n._v(" "),e("code",[n._v("数据类型 &别名 = 原名")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('int main() {\n\n\tint a = 10;\n\tint &b = a;\n\n\tcout << "a = " << a << endl; // 10\n\tcout << "b = " << b << endl; // 10\n\n\tb = 100;\n\n\tcout << "a = " << a << endl; // 100\n\tcout << "b = " << b << endl; // 100\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h3",{attrs:{id:"_2-2-引用注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-引用注意事项"}},[n._v("#")]),n._v(" 2.2 引用注意事项")]),n._v(" "),e("ul",[e("li",[n._v("引用必须初始化")]),n._v(" "),e("li",[n._v("引用在初始化后，不可以改变")])]),n._v(" "),e("p",[n._v("示例：")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('int main() {\n\n\tint a = 10;\n\tint b = 20;\n\t//int &c; //错误，引用必须初始化\n\tint &c = a; //一旦初始化后，就不可以更改\n\tc = b; //这是赋值操作，不是更改引用\n\n\tcout << "a = " << a << endl;\n\tcout << "b = " << b << endl;\n\tcout << "c = " << c << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h3",{attrs:{id:"_2-3-引用做函数参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-引用做函数参数"}},[n._v("#")]),n._v(" 2.3 引用做函数参数")]),n._v(" "),e("p",[n._v("**作用：**函数传参时，可以利用引用的技术让形参修饰实参")]),n._v(" "),e("p",[n._v("**优点：**可以简化指针修改实参")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//1. 值传递\nvoid mySwap01(int a, int b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//2. 地址传递\nvoid mySwap02(int* a, int* b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\n//3. 引用传递\nvoid mySwap03(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\n\tmySwap01(a, b);\n\tcout << "a:" << a << " b:" << b << endl;\n\n\tmySwap02(&a, &b);\n\tcout << "a:" << a << " b:" << b << endl;\n\n\tmySwap03(a, b);\n\tcout << "a:" << a << " b:" << b << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n\n')])])]),e("blockquote",[e("p",[n._v("总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单")])]),n._v(" "),e("h3",{attrs:{id:"_2-4-引用做函数返回值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-引用做函数返回值"}},[n._v("#")]),n._v(" 2.4 引用做函数返回值")]),n._v(" "),e("p",[n._v("作用：引用是可以作为函数的返回值存在的")]),n._v(" "),e("p",[n._v("注意："),e("strong",[n._v("不要返回局部变量引用")])]),n._v(" "),e("p",[n._v("用法：函数调用作为左值")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//返回局部变量引用\nint& test01() {\n\tint a = 10; //局部变量\n\treturn a;\n}\n\n//返回静态变量引用\nint& test02() {\n\tstatic int a = 20;\n\treturn a; // 返回a的引用\n}\n\nint main() {\n\n\t//不能返回局部变量的引用\n\tint& ref = test01();\n\tcout << "ref = " << ref << endl;  // 第一次返回正常\n\tcout << "ref = " << ref << endl;  // 第二次乱码\n\n\t//如果函数做左值，那么必须返回引用\n\tint& ref2 = test02();\n\tcout << "ref2 = " << ref2 << endl;  //10 正常返回，因为const 定义在全局区的常量区，只有程序全部退出再销毁\n\tcout << "ref2 = " << ref2 << endl;\n\n\ttest02() = 1000;  // 返回的引用\n\n\tcout << "ref2 = " << ref2 << endl;  // 1000\n\tcout << "ref2 = " << ref2 << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h3",{attrs:{id:"_2-5-引用的本质"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-引用的本质"}},[n._v("#")]),n._v(" 2.5 引用的本质")]),n._v(" "),e("p",[e("img",{attrs:{src:"C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.assets/image-20201017145311588.png",alt:"image-20201017145311588"}})]),n._v(" "),e("p",[n._v("本质："),e("strong",[n._v("引用的本质在c++内部实现是一个指针常量.")])]),n._v(" "),e("p",[n._v("讲解示例：")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//发现是引用，转换为 int* const ref = &a;\nvoid func(int& ref){\n\tref = 100; // ref是引用，转换为*ref = 100\n}\nint main(){\n    int a = 10;\n\n    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n    int& ref = a;\n    ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n\n    cout << "a:" << a << endl;  // 20\n    cout << "ref:" << ref << endl;  // 20\n\n    func(a);\n    cout << "a:" << a << endl;  // 100\n    return 0;\n}\n')])])]),e("p",[n._v("结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了")]),n._v(" "),e("h3",{attrs:{id:"_2-6-常量引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-常量引用"}},[n._v("#")]),n._v(" 2.6 常量引用")]),n._v(" "),e("p",[n._v("**作用：**常量引用主要用来修饰形参，防止误操作")]),n._v(" "),e("p",[n._v("在函数形参列表中，可以加==const修饰形参==，防止形参改变实参")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//引用使用的场景，通常用来修饰形参\nvoid showValue(const int& v) {\n\t//v += 10;\n\tcout << v << endl;\n}\n\nint main() {\n\n\t//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;\n\tconst int& ref = 10;\n\n\t//ref = 100;  //加入const后不可以修改变量\n\tcout << ref << endl;\n\n\t//函数中利用常量引用防止误操作修改实参\n\tint a = 10;\n\tshowValue(a);\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h2",{attrs:{id:"_3-函数提高"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-函数提高"}},[n._v("#")]),n._v(" 3 函数提高")]),n._v(" "),e("h3",{attrs:{id:"_3-1-函数默认参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-函数默认参数"}},[n._v("#")]),n._v(" 3.1 函数默认参数")]),n._v(" "),e("p",[n._v("在C++中，函数的形参列表中的形参是可以有默认值的。")]),n._v(" "),e("p",[n._v("语法："),e("code",[n._v("返回值类型 函数名 （参数= 默认值）{}")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('int func(int a, int b = 10, int c = 10) { \n\treturn a + b + c;\n}\n\n//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\nint func2(int a = 10, int b = 10);\nint func2(int a, int b) {\n\treturn a + b;\n}\n\nint main() {\n\n\tcout << "ret = " << func(20, 20) << endl;\n\tcout << "ret = " << func(100) << endl;\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),e("h3",{attrs:{id:"_3-2-函数占位参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-函数占位参数"}},[n._v("#")]),n._v(" 3.2 函数占位参数")]),n._v(" "),e("p",[n._v("C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置")]),n._v(" "),e("p",[e("strong",[n._v("语法：")]),n._v(" "),e("code",[n._v("返回值类型 函数名 (数据类型){}")])]),n._v(" "),e("p",[n._v("在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) {\n\tcout << "this is func" << endl;\n}\n\nint main() {\n\n\tfunc(10,10); //占位参数必须填补\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h3",{attrs:{id:"_3-3-函数重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-函数重载"}},[n._v("#")]),n._v(" 3.3 函数重载")]),n._v(" "),e("h4",{attrs:{id:"_3-3-1-函数重载概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-函数重载概述"}},[n._v("#")]),n._v(" 3.3.1 函数重载概述")]),n._v(" "),e("p",[n._v("**作用：**函数名可以相同，提高复用性")]),n._v(" "),e("p",[e("strong",[n._v("函数重载满足条件：")])]),n._v(" "),e("ul",[e("li",[n._v("同一个作用域下")]),n._v(" "),e("li",[n._v("函数名称相同")]),n._v(" "),e("li",[n._v("函数参数"),e("strong",[n._v("类型不同")]),n._v("  或者 "),e("strong",[n._v("个数不同")]),n._v(" 或者 "),e("strong",[n._v("顺序不同")])])]),n._v(" "),e("p",[e("strong",[n._v("注意:")]),n._v("  函数的返回值不可以作为函数重载的条件")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//函数重载需要函数都在同一个作用域下\nvoid func()\n{\n\tcout << "func 的调用！" << endl;\n}\nvoid func(int a)\n{\n\tcout << "func (int a) 的调用！" << endl;\n}\nvoid func(double a)\n{\n\tcout << "func (double a)的调用！" << endl;\n}\nvoid func(int a ,double b)\n{\n\tcout << "func (int a ,double b) 的调用！" << endl;\n}\nvoid func(double a ,int b)\n{\n\tcout << "func (double a ,int b)的调用！" << endl;\n}\n\n//函数返回值不可以作为函数重载条件\n//int func(double a, int b)\n//{\n//\tcout << "func (double a ,int b)的调用！" << endl;\n//}\n\nint main() {\n\n\tfunc();\n\tfunc(10);\n\tfunc(3.14);\n\tfunc(10,3.14);\n\tfunc(3.14 , 10);\n\t\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_3-3-2-函数重载注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-函数重载注意事项"}},[n._v("#")]),n._v(" 3.3.2 函数重载注意事项")]),n._v(" "),e("ul",[e("li",[n._v("引用作为重载条件")]),n._v(" "),e("li",[n._v("函数重载碰到函数默认参数")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//函数重载注意事项\n//1、引用作为重载条件\n\nvoid func(int &a)\n{\n\tcout << "func (int &a) 调用 " << endl;\n}\n\nvoid func(const int &a)\n{\n\tcout << "func (const int &a) 调用 " << endl;\n}\n\n\n//2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b = 10)\n{\n\tcout << "func2(int a, int b = 10) 调用" << endl;\n}\n\nvoid func2(int a)\n{\n\tcout << "func2(int a) 调用" << endl;\n}\n\nint main() {\n\t\n\tint a = 10;\n\tfunc(a); //调用无const的func，原因是等价于 int &a = 10 \t不合法\n\tfunc(10);//调用有const的func，原因是等价于 const int &a = 10 合法\n\n\n\t//func2(10); //碰到默认参数产生歧义，需要避免\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h2",{attrs:{id:"_4-类和对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-类和对象"}},[n._v("#")]),n._v(" "),e("strong",[n._v("4")]),n._v(" 类和对象")]),n._v(" "),e("p",[n._v("C++面向对象的三大特性为：==封装、继承、多态==")]),n._v(" "),e("p",[n._v("C++认为==万事万物都皆为对象==，对象上有其属性和行为")]),n._v(" "),e("p",[e("strong",[n._v("例如：")])]),n._v(" "),e("p",[n._v("​\t人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...")]),n._v(" "),e("p",[n._v("​\t车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...")]),n._v(" "),e("p",[n._v("​\t具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类")]),n._v(" "),e("h3",{attrs:{id:"_4-1-封装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-封装"}},[n._v("#")]),n._v(" 4.1 封装")]),n._v(" "),e("h4",{attrs:{id:"_4-1-1-封装的意义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-1-封装的意义"}},[n._v("#")]),n._v(" 4.1.1  封装的意义")]),n._v(" "),e("p",[n._v("封装是C++面向对象三大特性之一")]),n._v(" "),e("p",[n._v("封装的意义：")]),n._v(" "),e("ul",[e("li",[n._v("将属性和行为作为一个整体，表现生活中的事物")]),n._v(" "),e("li",[n._v("将属性和行为加以权限控制")])]),n._v(" "),e("p",[e("strong",[n._v("封装意义一：")])]),n._v(" "),e("p",[n._v("​\t在设计类的时候，属性和行为写在一起，表现事物")]),n._v(" "),e("p",[e("strong",[n._v("语法：")]),n._v(" "),e("code",[n._v("class 类名{ 访问权限： 属性 / 行为 };")])]),n._v(" "),e("p",[n._v("**示例1：**设计一个圆类，求圆的周长")]),n._v(" "),e("p",[e("strong",[n._v("示例代码：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//圆周率\nconst double PI = 3.14;\n\n//1、封装的意义\n//将属性和行为作为一个整体，用来表现生活中的事物\n\n//封装一个圆类，求圆的周长\n//class代表设计一个类，后面跟着的是类名\nclass Circle\n{\npublic:  //访问权限  公共的权限\n\n\t//属性\n\tint m_r;//半径\n\n\t//行为\n\t//获取到圆的周长\n\tdouble calculateZC()\n\t{\n\t\t//2 * pi  * r\n\t\t//获取圆的周长\n\t\treturn  2 * PI * m_r;\n\t}\n};\n\nint main() {\n\t//通过圆类，创建圆的对象\n\t// c1就是一个具体的圆\n\tCircle c1;\n\tc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n\t//2 * pi * 10 = = 62.8\n\tcout << "圆的周长为： " << c1.calculateZC() << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号")]),n._v(" "),e("p",[e("strong",[n._v("示例2代码：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//学生类\nclass Student {\npublic:\n\tvoid setName(string name) {\n\t\tm_name = name;\n\t}\n\tvoid setID(int id) {\n\t\tm_id = id;\n\t}\n\n\tvoid showStudent() {\n\t\tcout << "name:" << m_name << " ID:" << m_id << endl;\n\t}\npublic:\n\tstring m_name;\n\tint m_id;\n};\n\nint main() {\n\n\tStudent stu;\n\tstu.setName("德玛西亚");\n\tstu.setID(250);\n\tstu.showStudent();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n\n')])])]),e("p",[e("strong",[n._v("封装意义二：")])]),n._v(" "),e("p",[n._v("类在设计时，可以把属性和行为放在不同的权限下，加以控制")]),n._v(" "),e("p",[n._v("访问权限有三种：")]),n._v(" "),e("ol",[e("li",[n._v("public        公共权限")]),n._v(" "),e("li",[n._v("protected 保护权限")]),n._v(" "),e("li",[n._v("private      私有权限")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//三种权限\n//公共权限  public     类内可以访问  类外可以访问\n//保护权限  protected  类内可以访问  类外不可以访问（子类可以访问）\n//私有权限  private    类内可以访问  类外不可以访问(子类不能访问)\n\nclass Person\n{\n\t//姓名  公共权限\npublic:\n\tstring m_Name;\n\n\t//汽车  保护权限\nprotected:\n\tstring m_Car;\n\n\t//银行卡密码  私有权限\nprivate:\n\tint m_Password;\n\npublic:\n\tvoid func()\n\t{\n\t\tm_Name = "张三";\n\t\tm_Car = "拖拉机";\n\t\tm_Password = 123456;\n\t}\n};\n\nint main() {\n\n\tPerson p;\n\tp.m_Name = "李四";\n\t//p.m_Car = "奔驰";  //保护权限类外访问不到\n\t//p.m_Password = 123; //私有权限类外访问不到\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-1-2-struct和class区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-2-struct和class区别"}},[n._v("#")]),n._v(" 4.1.2 struct和class区别")]),n._v(" "),e("p",[n._v("在C++中 struct和class唯一的"),e("strong",[n._v("区别")]),n._v("就在于 "),e("strong",[n._v("默认的访问权限不同")])]),n._v(" "),e("p",[n._v("区别：")]),n._v(" "),e("ul",[e("li",[n._v("struct 默认权限为公共")]),n._v(" "),e("li",[n._v("class   默认权限为私有")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class C1\n{\n\tint  m_A; //默认是私有权限\n};\n\nstruct C2\n{\n\tint m_A;  //默认是公共权限\n};\n\nint main() {\n\n\tC1 c1;\n\tc1.m_A = 10; //错误，访问权限是私有\n\n\tC2 c2;\n\tc2.m_A = 10; //正确，访问权限是公共\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-1-3-成员属性设置为私有"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-3-成员属性设置为私有"}},[n._v("#")]),n._v(" 4.1.3 成员属性设置为私有")]),n._v(" "),e("p",[n._v("**优点1：**将所有成员属性设置为私有，可以自己控制读写权限")]),n._v(" "),e("p",[n._v("**优点2：**对于写权限，我们可以检测数据的有效性")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person {\npublic:\n\t//姓名设置可读可写\n\tvoid setName(string name) {\n\t\tm_Name = name;\n\t}\n\tstring getName()\n\t{\n\t\treturn m_Name;\n\t}\n\n\t//获取年龄 \n\tint getAge() {\n\t\treturn m_Age;\n\t}\n\t//设置年龄\n\tvoid setAge(int age) {\n\t\tif (age < 0 || age > 150) {\n\t\t\tcout << "你个老妖精!" << endl;\n\t\t\treturn;\n\t\t}\n\t\tm_Age = age;\n\t}\n\n\t//情人设置为只写\n\tvoid setLover(string lover) {\n\t\tm_Lover = lover;\n\t}\n\nprivate:\n\tstring m_Name; //可读可写  姓名\n\t\n\tint m_Age; //只读  年龄\n\n\tstring m_Lover; //只写  情人\n};\n\n\nint main() {\n\n\tPerson p;\n\t//姓名设置\n\tp.setName("张三");\n\tcout << "姓名： " << p.getName() << endl;\n\n\t//年龄设置\n\tp.setAge(50);\n\tcout << "年龄： " << p.getAge() << endl;\n\n\t//情人设置\n\tp.setLover("苍井");\n\t//cout << "情人： " << p.m_Lover << endl;  //只写属性，不可以读取\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[e("strong",[n._v("练习案例1：设计立方体类")])]),n._v(" "),e("p",[n._v("设计立方体类(Cube)")]),n._v(" "),e("p",[n._v("求出立方体的面积和体积")]),n._v(" "),e("p",[n._v("分别用全局函数和成员函数判断两个立方体是否相等。")]),n._v(" "),e("p",[e("img",{attrs:{src:"assets/1545533548532.png",alt:"1545533548532"}})]),n._v(" "),e("p",[e("strong",[n._v("练习案例2：点和圆的关系")])]),n._v(" "),e("p",[n._v("设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。")]),n._v(" "),e("p",[e("img",{attrs:{src:"assets/1545533829184.png",alt:"1545533829184"}})]),n._v(" "),e("h3",{attrs:{id:"_4-2-对象的初始化和清理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-对象的初始化和清理"}},[n._v("#")]),n._v(" 4.2 对象的初始化和清理")]),n._v(" "),e("ul",[e("li",[n._v("生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全")]),n._v(" "),e("li",[n._v("C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。")])]),n._v(" "),e("h4",{attrs:{id:"_4-2-1-构造函数和析构函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-构造函数和析构函数"}},[n._v("#")]),n._v(" 4.2.1 构造函数和析构函数")]),n._v(" "),e("p",[n._v("对象的"),e("strong",[n._v("初始化和清理")]),n._v("也是两个非常重要的安全问题")]),n._v(" "),e("p",[n._v("​\t一个对象或者变量没有初始状态，对其使用后果是未知")]),n._v(" "),e("p",[n._v("​\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题")]),n._v(" "),e("p",[n._v("c++利用了"),e("strong",[n._v("构造函数")]),n._v("和"),e("strong",[n._v("析构函数")]),n._v("解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。")]),n._v(" "),e("p",[n._v("对象的初始化和清理工作是编译器强制要我们做的事情，因此如果"),e("strong",[n._v("我们不提供构造和析构，编译器会提供")])]),n._v(" "),e("p",[e("strong",[n._v("编译器提供的构造函数和析构函数是空实现。")])]),n._v(" "),e("ul",[e("li",[n._v("构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。")]),n._v(" "),e("li",[n._v("析构函数：主要作用在于对象"),e("strong",[n._v("销毁前")]),n._v("系统自动调用，执行一些清理工作。")])]),n._v(" "),e("p",[e("strong",[n._v("构造函数语法：")]),e("code",[n._v("类名(){}")])]),n._v(" "),e("ol",[e("li",[n._v("构造函数，没有返回值也不写void")]),n._v(" "),e("li",[n._v("函数名称与类名相同")]),n._v(" "),e("li",[n._v("构造函数可以有参数，因此可以发生重载")]),n._v(" "),e("li",[n._v("程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次")])]),n._v(" "),e("p",[e("strong",[n._v("析构函数语法：")]),n._v(" "),e("code",[n._v("~类名(){}")])]),n._v(" "),e("ol",[e("li",[n._v("析构函数，没有返回值也不写void")]),n._v(" "),e("li",[n._v("函数名称与类名相同,在名称前加上符号  ~")]),n._v(" "),e("li",[n._v("析构函数不可以有参数，因此不可以发生重载")]),n._v(" "),e("li",[n._v("程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person\n{\npublic:\n\t//构造函数\n\tPerson()\n\t{\n\t\tcout << "Person的构造函数调用" << endl;\n\t}\n\t//析构函数\n\t~Person()\n\t{\n\t\tcout << "Person的析构函数调用" << endl;\n\t}\n\n};\n\nvoid test01()\n{\n\tPerson p;\n}\n\nint main() {\n\t\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-2-2-构造函数的分类及调用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-构造函数的分类及调用"}},[n._v("#")]),n._v(" 4.2.2 构造函数的分类及调用")]),n._v(" "),e("p",[n._v("两种分类方式：")]),n._v(" "),e("p",[n._v("​\t按参数分为： 有参构造和无参构造")]),n._v(" "),e("p",[n._v("​\t按类型分为： 普通构造和拷贝构造")]),n._v(" "),e("p",[n._v("三种调用方式：")]),n._v(" "),e("p",[n._v("​\t括号法")]),n._v(" "),e("p",[n._v("​\t显示法")]),n._v(" "),e("p",[n._v("​\t隐式转换法")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//1、构造函数分类\n// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数\n// 按照类型分类分为 普通构造和拷贝构造\n\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << "无参构造函数!" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << "有参构造函数!" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {  // 必须用const，保证不修改\n\t\tage = p.age;  // 将实例的属性age拷贝一份age\n\t\tcout << "拷贝构造函数!" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << "析构函数!" << endl;\n\t}\npublic:\n\tint age;\n};\n\n//2、构造函数的调用\n//调用无参构造函数\nvoid test01() {\n\tPerson p; //调用无参构造函数\n}\n\n//调用有参的构造函数\nvoid test02() {\n\n\t//2.1  括号法，常用\n\tPerson p1(10);\n\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n\t//Person p2();\n\n\t//2.2 显式法\n\tPerson p2 = Person(10); \n\tPerson p3 = Person(p2);  // 传入实例则触发拷贝构造函数\n\t//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n\t//2.3 隐式转换法\n\tPerson p4 = 10; // Person p4 = Person(10); \n\tPerson p5 = p4; // Person p5 = Person(p4); \n\n\t//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n\t//Person p5(p4);\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-2-3-拷贝构造函数调用时机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-3-拷贝构造函数调用时机"}},[n._v("#")]),n._v(" 4.2.3 拷贝构造函数调用时机")]),n._v(" "),e("p",[n._v("C++中拷贝构造函数调用时机通常有三种情况")]),n._v(" "),e("ul",[e("li",[n._v("使用一个已经创建完毕的对象来初始化一个新对象")]),n._v(" "),e("li",[n._v("值传递的方式给函数参数传值")]),n._v(" "),e("li",[n._v("以值方式返回局部对象")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person {\npublic:\n\tPerson() {\n\t\tcout << "无参构造函数!" << endl;\n\t\tmAge = 0;\n\t}\n\tPerson(int age) {\n\t\tcout << "有参构造函数!" << endl;\n\t\tmAge = age;\n\t}\n\tPerson(const Person& p) {\n\t\tcout << "拷贝构造函数!" << endl;\n\t\tmAge = p.mAge;\n\t}\n\t//析构函数在释放内存之前调用\n\t~Person() {\n\t\tcout << "析构函数!" << endl;\n\t}\npublic:\n\tint mAge;\n};\n\n//1. 使用一个已经创建完毕的对象来初始化一个新对象\nvoid test01() {\n\n\tPerson man(100); //p对象已经创建完毕\n\tPerson newman(man); //调用拷贝构造函数\n\tPerson newman2 = man; //拷贝构造\n\n\t//Person newman3;\n\t//newman3 = man; //不是调用拷贝构造函数，赋值操作\n}\n\n//2. 值传递的方式给函数参数传值\n//相当于Person p1 = p;\nvoid doWork(Person p1) {}\nvoid test02() {\n\tPerson p; //无参构造函数\n\tdoWork(p);\n}\n\n//3. 以值方式返回局部对象\nPerson doWork2()\n{\n\tPerson p1;\n\tcout << (int *)&p1 << endl;\n\treturn p1;\n}\n\nvoid test03()\n{\n\tPerson p = doWork2();\n\tcout << (int *)&p << endl;\n}\n\n\nint main() {\n\n\t//test01();\n\t//test02();\n\ttest03();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-2-4-构造函数调用规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-4-构造函数调用规则"}},[n._v("#")]),n._v(" 4.2.4 构造函数调用规则")]),n._v(" "),e("p",[n._v("默认情况下，c++编译器至少给一个类添加3个函数")]),n._v(" "),e("p",[n._v("1．默认构造函数(无参，函数体为空)")]),n._v(" "),e("p",[n._v("2．默认析构函数(无参，函数体为空)")]),n._v(" "),e("p",[n._v("3．默认拷贝构造函数，对属性进行值拷贝，将类中的所有属性进行拷贝")]),n._v(" "),e("p",[n._v("构造函数调用规则如下：")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造")])]),n._v(" "),e("li",[e("p",[n._v("如果用户定义拷贝构造函数，c++不会再提供其他构造函数")])])]),n._v(" "),e("p",[n._v("示例：")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << "无参构造函数!" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << "有参构造函数!" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << "拷贝构造函数!" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << "析构函数!" << endl;\n\t}\npublic:\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(18);\n\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\n\tPerson p2(p1);\n\n\tcout << "p2的年龄为： " << p2.age << endl;\n}\n\nvoid test02()\n{\n\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\n\tPerson p1; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p2(10); //用户提供的有参\n\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供\n\n\t//如果用户提供拷贝构造，编译器不会提供其他构造函数\n\tPerson p4; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p5(10); //此时如果用户自己没有提供有参，会出错\n\tPerson p6(p5); //用户自己提供拷贝构造\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-2-5-深拷贝与浅拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-5-深拷贝与浅拷贝"}},[n._v("#")]),n._v(" 4.2.5 深拷贝与浅拷贝")]),n._v(" "),e("p",[n._v("深浅拷贝是面试经典问题，也是常见的一个坑")]),n._v(" "),e("p",[n._v("浅拷贝：简单的赋值拷贝操作")]),n._v(" "),e("p",[n._v("深拷贝：在堆区重新申请空间，进行拷贝操作")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << "无参构造函数!" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int age ,int height) {\n\t\t\n\t\tcout << "有参构造函数!" << endl;\n\n\t\tm_age = age;\n\t\tm_height = new int(height);\n\t\t\n\t}\n\t//拷贝构造函数  \n\tPerson(const Person& p) {\n\t\tcout << "拷贝构造函数!" << endl;\n\t\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n\t\tm_age = p.m_age;\n\t\tm_height = new int(*p.m_height);  // 深拷贝，如果不写构造函数则是浅拷贝\n\n\t}\n\n\t//析构函数\n\t~Person() {\n\t\tcout << "析构函数!" << endl;\n\t\tif (m_height != NULL)\n\t\t{\n\t\t\tdelete m_height;\n\t\t}\n\t}\npublic:\n\tint m_age;\n\tint* m_height;\n};\n\nvoid test01()\n{\n\tPerson p1(18, 180);\n\n\tPerson p2(p1);\n\n\tcout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;\n\n\tcout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("blockquote",[e("p",[n._v("总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题")])]),n._v(" "),e("h4",{attrs:{id:"_4-2-6-初始化列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-6-初始化列表"}},[n._v("#")]),n._v(" 4.2.6 初始化列表")]),n._v(" "),e("p",[e("strong",[n._v("作用：")])]),n._v(" "),e("p",[n._v("C++提供了初始化列表语法，用来初始化属性")]),n._v(" "),e("p",[e("strong",[n._v("语法：")]),e("code",[n._v("构造函数()：属性1(值1),属性2（值2）... {}")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person {\npublic:\n\n\t////传统方式初始化\n\t//Person(int a, int b, int c) {\n\t//\tm_A = a;\n\t//\tm_B = b;\n\t//\tm_C = c;\n\t//}\n\n\t//初始化列表方式初始化\n\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\n\tvoid PrintPerson() {\n\t\tcout << "mA:" << m_A << endl;\n\t\tcout << "mB:" << m_B << endl;\n\t\tcout << "mC:" << m_C << endl;\n\t}\nprivate:\n\tint m_A;\n\tint m_B;\n\tint m_C;\n};\n\nint main() {\n\tPerson p(1, 2, 3);\n\tp.PrintPerson();\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-2-7-类对象作为类成员"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-7-类对象作为类成员"}},[n._v("#")]),n._v(" 4.2.7 类对象作为类成员")]),n._v(" "),e("p",[n._v("C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员")]),n._v(" "),e("p",[n._v("例如：")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class A {}\nclass B\n{\n    A a；\n}\n")])])]),e("p",[n._v("B类中有对象A作为成员，A为对象成员")]),n._v(" "),e("p",[n._v("那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Phone\n{\npublic:\n\tPhone(string name)\n\t{\n\t\tm_PhoneName = name;\n\t\tcout << "Phone构造" << endl;\n\t}\n\n\t~Phone()\n\t{\n\t\tcout << "Phone析构" << endl;\n\t}\n\n\tstring m_PhoneName;\n\n};\n\n\nclass Person\n{\npublic:\n\n\t//初始化列表可以告诉编译器调用哪一个构造函数\n\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n\t{\n\t\tcout << "Person构造" << endl;\n\t}\n\n\t~Person()\n\t{\n\t\tcout << "Person析构" << endl;\n\t}\n\n\tvoid playGame()\n\t{\n\t\tcout << m_Name << " 使用" << m_Phone.m_PhoneName << " 牌手机! " << endl;\n\t}\n\n\tstring m_Name;\n\tPhone m_Phone;\n\n};\nvoid test01()\n{\n\t//当类中成员是其他类对象时，我们称该成员为 对象成员\n\t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造\n\t//析构顺序与构造相反\n\tPerson p("张三" , "苹果X");\n\tp.playGame();\n\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-2-8-静态成员"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-8-静态成员"}},[n._v("#")]),n._v(" 4.2.8 静态成员")]),n._v(" "),e("p",[n._v("静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员")]),n._v(" "),e("p",[n._v("静态成员分为：")]),n._v(" "),e("ul",[e("li",[n._v("静态成员变量\n"),e("ul",[e("li",[n._v("所有对象共享同一份数据")]),n._v(" "),e("li",[n._v("在编译阶段分配内存")]),n._v(" "),e("li",[n._v("类内声明，类外初始化")])])]),n._v(" "),e("li",[n._v("静态成员函数\n"),e("ul",[e("li",[n._v("所有对象共享同一个函数")]),n._v(" "),e("li",[n._v("静态成员函数只能访问静态成员变量")])])])]),n._v(" "),e("p",[n._v("**示例1 ：**静态成员变量")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person\n{\n\t\npublic:\n\n\tstatic int m_A; //静态成员变量\n\n\t//静态成员变量特点：\n\t//1 在编译阶段分配内存\n\t//2 类内声明，类外初始化\n\t//3 所有对象共享同一份数据\n\nprivate:\n\tstatic int m_B; //静态成员变量也是有访问权限的\n};\nint Person::m_A = 10;\nint Person::m_B = 10;\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.m_A = 100;\n\tcout << "p1.m_A = " << p1.m_A << endl;\n\n\tPerson p2;\n\tp2.m_A = 200;\n\tcout << "p1.m_A = " << p1.m_A << endl; //共享同一份数据\n\tcout << "p2.m_A = " << p2.m_A << endl;\n\n\t//2、通过类名\n\tcout << "m_A = " << Person::m_A << endl;\n\n\t//cout << "m_B = " << Person::m_B << endl; //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("**示例2：**静态成员函数")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person\n{\n\npublic:\n\t//静态成员函数特点：\n\t//1 程序共享一个函数\n\t//2 静态成员函数只能访问静态成员变量\n\t\n\tstatic void func()\n\t{\n\t\tcout << "func调用" << endl;\n\t\tm_A = 100;\n\t\t//m_B = 100; //错误，不可以访问非静态成员变量\n\t}\n\n\tstatic int m_A; //静态成员变量\n\tint m_B; // \nprivate:\n\t//静态成员函数也是有访问权限的\n\tstatic void func2()\n\t{\n\t\tcout << "func2调用" << endl;\n\t}\n};\nint Person::m_A = 10;\n\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.func();\n\n\t//2、通过类名\n\tPerson::func();\n\t//Person::func2(); //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h3",{attrs:{id:"_4-3-c-对象模型和this指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-c-对象模型和this指针"}},[n._v("#")]),n._v(" 4.3 C++对象模型和this指针")]),n._v(" "),e("h4",{attrs:{id:"_4-3-1-成员变量和成员函数分开存储"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-成员变量和成员函数分开存储"}},[n._v("#")]),n._v(" 4.3.1 成员变量和成员函数分开存储")]),n._v(" "),e("p",[n._v("在C++中，类内的成员变量和成员函数分开存储")]),n._v(" "),e("p",[n._v("只有非静态成员变量才属于类的对象上")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person {\npublic:\n\tPerson() {\n\t\tmA = 0;\n\t}\n\t//非静态成员变量占对象空间\n\tint mA;\n\t//静态成员变量不占对象空间\n\tstatic int mB; \n\t//函数也不占对象空间，所有函数共享一个函数实例\n\tvoid func() {\n\t\tcout << "mA:" << this->mA << endl;\n\t}\n\t//静态成员函数也不占对象空间\n\tstatic void sfunc() {\n\t}\n};\n\nint main() {\n\n\tcout << sizeof(Person) << endl;//  // C++编译器会给每个空对象分配一个字节的空间，是为了区分空对象占内存的位置\n  // 每个空对象也应该有一饿独一无二的内存地址\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-3-2-this指针概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-this指针概念"}},[n._v("#")]),n._v(" 4.3.2 this指针概念")]),n._v(" "),e("p",[n._v("通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的")]),n._v(" "),e("p",[n._v("每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码")]),n._v(" "),e("p",[n._v("那么问题是：这一块代码是如何区分那个对象调用自己的呢？")]),n._v(" "),e("p",[n._v("c++通过提供特殊的对象指针，this指针，解决上述问题。"),e("strong",[n._v("this指针指向被调用的成员函数所属的对象")])]),n._v(" "),e("p",[n._v("this指针是隐含每一个非静态成员函数内的一种指针")]),n._v(" "),e("p",[n._v("this指针不需要定义，直接使用即可")]),n._v(" "),e("p",[n._v("this指针的用途：")]),n._v(" "),e("ul",[e("li",[n._v("当形参和成员变量同名时，可用this指针来区分")]),n._v(" "),e("li",[n._v("在类的非静态成员函数中返回对象本身，可使用return *this")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//1、当形参和成员变量同名时，可用this指针来区分\n\t\tthis->age = age;  // 如果是 age = age 就没有效果了，this指向被调用的成员函数，\n\t}\n\n\tPerson& PersonAddPerson(Person p)\n\t{\n\t\tthis->age += p.age;\n\t\t//返回对象本身\n\t\treturn *this;\n\t}\n\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(10);\n\tcout << "p1.age = " << p1.age << endl;\n\n\tPerson p2(10);\n\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\n\tcout << "p2.age = " << p2.age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-3-3-空指针访问成员函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-3-空指针访问成员函数"}},[n._v("#")]),n._v(" 4.3.3 空指针访问成员函数")]),n._v(" "),e("p",[n._v("C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针")]),n._v(" "),e("p",[n._v("如果用到this指针，需要加以判断保证代码的健壮性、")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//空指针访问成员函数\nclass Person {\npublic:\n\n\tvoid ShowClassName() {\n\t\tcout << "我是Person类!" << endl;\n\t}\n\n\tvoid ShowPerson() {\n\t\tif (this == NULL) {  // 解决this指向问题\n\t\t\treturn;\n\t\t}\n\t\tcout << mAge << endl;  // 相当于 this->\n\t}\n\npublic:\n\tint mAge;\n};\n\nvoid test01()\n{\n\tPerson * p = NULL;\n\tp->ShowClassName(); //空指针，可以调用成员函数\n\tp->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-3-4-const修饰成员函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-4-const修饰成员函数"}},[n._v("#")]),n._v(" 4.3.4 const修饰成员函数")]),n._v(" "),e("p",[e("strong",[n._v("常函数：")])]),n._v(" "),e("ul",[e("li",[n._v("成员函数后加const后我们称为这个函数为"),e("strong",[n._v("常函数")])]),n._v(" "),e("li",[n._v("常函数内不可以修改成员属性")]),n._v(" "),e("li",[n._v("成员属性声明时加关键字mutable后，*在常函数中依然可以修改 *")])]),n._v(" "),e("p",[e("strong",[n._v("常对象：")])]),n._v(" "),e("ul",[e("li",[n._v("声明对象前加const称该对象为常对象")]),n._v(" "),e("li",[n._v("常对象只能调用常函数")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person {\npublic:\n\tPerson() {\n\t\tm_A = 0;\n\t\tm_B = 0;\n\t}\n\n\t//this指针的本质是一个指针常量，指针的指向不可修改\n\t//如果想让指针指向的值也不可以修改，需要声明常函数\n\tvoid ShowPerson() const {\n\t\t//const Type* const pointer;\n\t\t//this = NULL; //不能修改指针的指向 Person* const this;\n\t\t//this->mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n\t\t//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n\t\tthis->m_B = 100;\n\t}\n\n\tvoid MyFunc() const {\n\t\t//mA = 10000;\n\t}\n  \n  void func {}\n\npublic:\n\tint m_A;\n\tmutable int m_B; //可修改 可变的\n};\n\n\n//const修饰对象  常对象\nvoid test01() {\n\n\tconst Person person; //常量对象  \n\tcout << person.m_A << endl;\n\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\n\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n\t//常对象访问成员函数\n\tperson.func(); //常对象只能调用const的函数\n  person.ShowPerson();\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h3",{attrs:{id:"_4-4-友元"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-友元"}},[n._v("#")]),n._v(" 4.4 友元")]),n._v(" "),e("p",[n._v("生活中你的家有客厅(Public)，有你的卧室(Private)")]),n._v(" "),e("p",[n._v("客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去")]),n._v(" "),e("p",[n._v("但是呢，你也可以允许你的好闺蜜好基友进去。")]),n._v(" "),e("p",[n._v("在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术")]),n._v(" "),e("p",[n._v("友元的目的就是让一个函数或者类 访问另一个类中私有成员")]),n._v(" "),e("p",[n._v("友元的关键字为  ==friend==")]),n._v(" "),e("p",[n._v("友元的三种实现")]),n._v(" "),e("ul",[e("li",[n._v("全局函数做友元")]),n._v(" "),e("li",[n._v("类做友元")]),n._v(" "),e("li",[n._v("成员函数做友元")])]),n._v(" "),e("h4",{attrs:{id:"_4-4-1-全局函数做友元"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1-全局函数做友元"}},[n._v("#")]),n._v(" 4.4.1 全局函数做友元")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Building\n{\n\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\n\tfriend void goodGay(Building * building);\n\npublic:\n\n\tBuilding()\n\t{\n\t\tthis->m_SittingRoom = "客厅";\n\t\tthis->m_BedRoom = "卧室";\n\t}\n\n\npublic:\n\tstring m_SittingRoom; //客厅\n\nprivate:\n\tstring m_BedRoom; //卧室\n};\n\n\nvoid goodGay(Building * building)\n{\n\tcout << "好基友正在访问： " << building->m_SittingRoom << endl;\n\tcout << "好基友正在访问： " << building->m_BedRoom << endl;\n}\n\n\nvoid test01()\n{\n\tBuilding b;\n\tgoodGay(&b);\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-4-2-类做友元"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2-类做友元"}},[n._v("#")]),n._v(" 4.4.2 类做友元")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit();\n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\n\tfriend class goodGay;\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = "客厅";\n\tthis->m_BedRoom = "卧室";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << "好基友正在访问" << building->m_SittingRoom << endl;\n\tcout << "好基友正在访问" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay gg;\n\tgg.visit();\n\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-4-3-成员函数做友元"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-3-成员函数做友元"}},[n._v("#")]),n._v(" 4.4.3 成员函数做友元")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('\nclass Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\n\tvoid visit2(); \n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\n\tfriend void goodGay::visit();\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = "客厅";\n\tthis->m_BedRoom = "卧室";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << "好基友正在访问" << building->m_SittingRoom << endl;\n\tcout << "好基友正在访问" << building->m_BedRoom << endl;\n}\n\nvoid goodGay::visit2()\n{\n\tcout << "好基友正在访问" << building->m_SittingRoom << endl;\n\t//cout << "好基友正在访问" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay  gg;\n\tgg.visit();\n\n}\n\nint main(){\n    \n\ttest01();\n\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),e("h3",{attrs:{id:"_4-5-运算符重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-运算符重载"}},[n._v("#")]),n._v(" 4.5 运算符重载")]),n._v(" "),e("p",[n._v("运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型")]),n._v(" "),e("h4",{attrs:{id:"_4-5-1-加号运算符重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-1-加号运算符重载"}},[n._v("#")]),n._v(" 4.5.1 加号运算符重载")]),n._v(" "),e("p",[n._v("作用：实现两个自定义数据类型相加的运算")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person {\npublic:\n\tPerson() {};\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\t//成员函数实现 + 号运算符重载\n\tPerson operator+(const Person& p) {\n\t\tPerson temp;\n\t\ttemp.m_A = this->m_A + p.m_A;\n\t\ttemp.m_B = this->m_B + p.m_B;\n\t\treturn temp;\n\t}\n\n\npublic:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现 + 号运算符重载\n//Person operator+(const Person& p1, const Person& p2) {\n//\tPerson temp(0, 0);\n//\ttemp.m_A = p1.m_A + p2.m_A;\n//\ttemp.m_B = p1.m_B + p2.m_B;\n//\treturn temp;\n//}\n\n//运算符重载 可以发生函数重载 \nPerson operator+(const Person& p2, int val)  \n{\n\tPerson temp;\n\ttemp.m_A = p2.m_A + val;\n\ttemp.m_B = p2.m_B + val;\n\treturn temp;\n}\n\nvoid test() {\n\tPerson p1(10, 10);\n\tPerson p2(20, 20);\n\n\t//成员函数方式\n\tPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\n\tcout << "mA:" << p3.m_A << " mB:" << p3.m_B << endl;\n\n\tPerson p4 = p3 + 10; //相当于 operator+(p3,10)\n\tcout << "mA:" << p4.m_A << " mB:" << p4.m_B << endl;\n}\n\nint main() {\n\ttest();\n\tsystem("pause");\n\treturn 0;\n}\n')])])]),e("blockquote",[e("p",[n._v("总结1：对于内置的数据类型的表达式的的运算符是不可能改变的")])]),n._v(" "),e("blockquote",[e("p",[n._v("总结2：不要滥用运算符重载")])]),n._v(" "),e("h4",{attrs:{id:"_4-5-2-左移运算符重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-2-左移运算符重载"}},[n._v("#")]),n._v(" 4.5.2 左移运算符重载")]),n._v(" "),e("p",[n._v("作用：可以输出自定义数据类型")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person {\n\tfriend ostream& operator<<(ostream& out, Person& p);\n\npublic:\n\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\n\t//成员函数 实现不了  p << cout 不是我们想要的效果\n\t//void operator<<(Person& p){\n\t//}\n\nprivate:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现左移重载\n//ostream对象只能有一个\nostream& operator<<(ostream& out, Person& p) {\n\tout << "a:" << p.m_A << " b:" << p.m_B;\n\treturn out;\n}\n\nvoid test() {\n\n\tPerson p1(10, 20);\n\tcout << p1 << "hello world" << endl; //链式编程\n}\n\nint main() {\n\n\ttest();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("blockquote",[e("p",[n._v("总结：重载左移运算符配合友元可以实现输出自定义数据类型")])]),n._v(" "),e("h4",{attrs:{id:"_4-5-3-递增运算符重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-3-递增运算符重载"}},[n._v("#")]),n._v(" 4.5.3 递增运算符重载")]),n._v(" "),e("p",[n._v("作用： 通过重载递增运算符，实现自己的整型数据")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('\nclass MyInteger {\n\n\tfriend ostream& operator<<(ostream& out, MyInteger myint);\n\npublic:\n\tMyInteger() {\n\t\tm_Num = 0;\n\t}\n\t//前置++\n\tMyInteger& operator++() {\n\t\t//先++\n\t\tm_Num++;\n\t\t//再返回\n\t\treturn *this;\n\t}\n\n\t//后置++\n\tMyInteger operator++(int) {\n\t\t//先返回\n\t\tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n\t\tm_Num++;\n\t\treturn temp;\n\t}\n\nprivate:\n\tint m_Num;\n};\n\n\nostream& operator<<(ostream& out, MyInteger myint) {\n\tout << myint.m_Num;\n\treturn out;\n}\n\n\n//前置++ 先++ 再返回\nvoid test01() {\n\tMyInteger myInt;\n\tcout << ++myInt << endl;\n\tcout << myInt << endl;\n}\n\n//后置++ 先返回 再++\nvoid test02() {\n\n\tMyInteger myInt;\n\tcout << myInt++ << endl;\n\tcout << myInt << endl;\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("blockquote",[e("p",[n._v("总结： 前置递增返回引用，后置递增返回值")])]),n._v(" "),e("h4",{attrs:{id:"_4-5-4-赋值运算符重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-4-赋值运算符重载"}},[n._v("#")]),n._v(" 4.5.4 赋值运算符重载")]),n._v(" "),e("p",[n._v("c++编译器至少给一个类添加4个函数")]),n._v(" "),e("ol",[e("li",[n._v("默认构造函数(无参，函数体为空)")]),n._v(" "),e("li",[n._v("默认析构函数(无参，函数体为空)")]),n._v(" "),e("li",[n._v("默认拷贝构造函数，对属性进行值拷贝")]),n._v(" "),e("li",[n._v("赋值运算符 operator=, 对属性进行值拷贝")])]),n._v(" "),e("p",[n._v("如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//将年龄数据开辟到堆区\n\t\tm_Age = new int(age);\n\t}\n\n\t//重载赋值运算符 \n\tPerson& operator=(Person &p)\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t\t//编译器提供的代码是浅拷贝\n\t\t//m_Age = p.m_Age;\n\n\t\t//提供深拷贝 解决浅拷贝的问题\n\t\tm_Age = new int(*p.m_Age);\n\n\t\t//返回自身\n\t\treturn *this;\n\t}\n\n\n\t~Person()\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t}\n\n\t//年龄的指针\n\tint *m_Age;\n\n};\n\n\nvoid test01()\n{\n\tPerson p1(18);\n\n\tPerson p2(20);\n\n\tPerson p3(30);\n\n\tp3 = p2 = p1; //赋值操作\n\n\tcout << "p1的年龄为：" << *p1.m_Age << endl;\n\n\tcout << "p2的年龄为：" << *p2.m_Age << endl;\n\n\tcout << "p3的年龄为：" << *p3.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\t//int a = 10;\n\t//int b = 20;\n\t//int c = 30;\n\n\t//c = b = a;\n\t//cout << "a = " << a << endl;\n\t//cout << "b = " << b << endl;\n\t//cout << "c = " << c << endl;\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-5-5-关系运算符重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-5-关系运算符重载"}},[n._v("#")]),n._v(" 4.5.5 关系运算符重载")]),n._v(" "),e("p",[n._v("**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Person\n{\npublic:\n\tPerson(string name, int age)\n\t{\n\t\tthis->m_Name = name;\n\t\tthis->m_Age = age;\n\t};\n\n\tbool operator==(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbool operator!=(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstring m_Name;\n\tint m_Age;\n};\n\nvoid test01()\n{\n\t//int a = 0;\n\t//int b = 0;\n\n\tPerson a("孙悟空", 18);\n\tPerson b("孙悟空", 18);\n\n\tif (a == b)\n\t{\n\t\tcout << "a和b相等" << endl;\n\t}\n\telse\n\t{\n\t\tcout << "a和b不相等" << endl;\n\t}\n\n\tif (a != b)\n\t{\n\t\tcout << "a和b不相等" << endl;\n\t}\n\telse\n\t{\n\t\tcout << "a和b相等" << endl;\n\t}\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-5-6-函数调用运算符重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-6-函数调用运算符重载"}},[n._v("#")]),n._v(" 4.5.6 函数调用运算符重载")]),n._v(" "),e("ul",[e("li",[n._v("函数调用运算符 ()  也可以重载")]),n._v(" "),e("li",[n._v("由于重载后使用的方式非常像函数的调用，因此称为仿函数")]),n._v(" "),e("li",[n._v("仿函数没有固定写法，非常灵活")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class MyPrint\n{\npublic:\n\tvoid operator()(string text)\n\t{\n\t\tcout << text << endl;\n\t}\n\n};\nvoid test01()\n{\n\t//重载的（）操作符 也称为仿函数\n\tMyPrint myFunc;\n\tmyFunc("hello world");\n}\n\n\nclass MyAdd\n{\npublic:\n\tint operator()(int v1, int v2)\n\t{\n\t\treturn v1 + v2;\n\t}\n};\n\nvoid test02()\n{\n\tMyAdd add;\n\tint ret = add(10, 10);\n\tcout << "ret = " << ret << endl;\n\n\t//匿名对象调用  \n\tcout << "MyAdd()(100,100) = " << MyAdd()(100, 100) << endl;\n}\n\nint main() {\n\n\ttest01();\n\ttest02();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h3",{attrs:{id:"_4-6-继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-继承"}},[n._v("#")]),n._v(" 4.6  继承")]),n._v(" "),e("p",[e("strong",[n._v("继承是面向对象三大特性之一")])]),n._v(" "),e("p",[n._v("有些类与类之间存在特殊的关系，例如下图中：")]),n._v(" "),e("p",[e("img",{attrs:{src:"assets/1544861202252.png",alt:"1544861202252"}})]),n._v(" "),e("p",[n._v("我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。")]),n._v(" "),e("p",[n._v("这个时候我们就可以考虑利用继承的技术，减少重复代码")]),n._v(" "),e("h4",{attrs:{id:"_4-6-1-继承的基本语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-1-继承的基本语法"}},[n._v("#")]),n._v(" 4.6.1 继承的基本语法")]),n._v(" "),e("p",[n._v("例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同")]),n._v(" "),e("p",[n._v("接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处")]),n._v(" "),e("p",[e("strong",[n._v("普通实现：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//Java页面\nclass Java \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << "首页、公开课、登录、注册...（公共头部）" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << "Java,Python,C++...(公共分类列表)" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << "JAVA学科视频" << endl;\n\t}\n};\n//Python页面\nclass Python\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << "首页、公开课、登录、注册...（公共头部）" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << "Java,Python,C++...(公共分类列表)" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << "Python学科视频" << endl;\n\t}\n};\n//C++页面\nclass CPP \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << "首页、公开课、登录、注册...（公共头部）" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << "Java,Python,C++...(公共分类列表)" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << "C++学科视频" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << "Java下载视频页面如下： " << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << "--------------------" << endl;\n\n\t//Python页面\n\tcout << "Python下载视频页面如下： " << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << "--------------------" << endl;\n\n\t//C++页面\n\tcout << "C++下载视频页面如下： " << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[e("strong",[n._v("继承实现：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//公共页面\nclass BasePage\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << "首页、公开课、登录、注册...（公共头部）" << endl;\n\t}\n\n\tvoid footer()\n\t{\n\t\tcout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << "Java,Python,C++...(公共分类列表)" << endl;\n\t}\n\n};\n\n//Java页面\nclass Java : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << "JAVA学科视频" << endl;\n\t}\n};\n//Python页面\nclass Python : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << "Python学科视频" << endl;\n\t}\n};\n//C++页面\nclass CPP : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << "C++学科视频" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << "Java下载视频页面如下： " << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << "--------------------" << endl;\n\n\t//Python页面\n\tcout << "Python下载视频页面如下： " << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << "--------------------" << endl;\n\n\t//C++页面\n\tcout << "C++下载视频页面如下： " << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[e("strong",[n._v("总结：")])]),n._v(" "),e("p",[n._v("继承的好处：==可以减少重复的代码==")]),n._v(" "),e("p",[n._v("class A : public B;")]),n._v(" "),e("p",[n._v("A 类称为子类 或 派生类")]),n._v(" "),e("p",[n._v("B 类称为父类 或 基类")]),n._v(" "),e("p",[e("strong",[n._v("派生类中的成员，包含两大部分")]),n._v("：")]),n._v(" "),e("p",[n._v("一类是从基类继承过来的，一类是自己增加的成员。")]),n._v(" "),e("p",[n._v("从基类继承过过来的表现其共性，而新增的成员体现了其个性。")]),n._v(" "),e("h4",{attrs:{id:"_4-6-2-继承方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-2-继承方式"}},[n._v("#")]),n._v(" 4.6.2 继承方式")]),n._v(" "),e("p",[n._v("继承的语法："),e("code",[n._v("class 子类 : 继承方式 父类")])]),n._v(" "),e("p",[e("strong",[n._v("继承方式一共有三种：")])]),n._v(" "),e("ul",[e("li",[n._v("公共继承")]),n._v(" "),e("li",[n._v("保护继承")]),n._v(" "),e("li",[n._v("私有继承")])]),n._v(" "),e("p",[e("img",{attrs:{src:"assets/clip_image002.png",alt:"img"}})]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class Base1\n{\npublic: \n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\n\n//公共继承\nclass Son1 :public Base1\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 public权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\n\nvoid myClass()\n{\n\tSon1 s1;\n\ts1.m_A; //其他类只能访问到公共权限\n}\n\n//保护继承\nclass Base2\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son2:protected Base2\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 protected权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\nvoid myClass2()\n{\n\tSon2 s;\n\t//s.m_A; //不可访问\n}\n\n//私有继承\nclass Base3\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son3:private Base3\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 private权限\n\t\tm_B; //可访问 private权限\n\t\t//m_C; //不可访问\n\t}\n};\nclass GrandSon3 :public Son3\n{\npublic:\n\tvoid func()\n\t{\n\t\t//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到\n\t\t//m_A;\n\t\t//m_B;\n\t\t//m_C;\n\t}\n};\n")])])]),e("h4",{attrs:{id:"_4-6-3-继承中的对象模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-3-继承中的对象模型"}},[n._v("#")]),n._v(" 4.6.3 继承中的对象模型")]),n._v(" "),e("p",[n._v("**问题：**从父类继承过来的成员，哪些属于子类对象中？")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Base\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C; //私有成员只是被隐藏了，但是还是会继承下去\n};\n\n//公共继承\nclass Son :public Base\n{\npublic:\n\tint m_D;\n};\n\nvoid test01()\n{\n\tcout << "sizeof Son = " << sizeof(Son) << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("利用工具查看：")]),n._v(" "),e("p",[e("img",{attrs:{src:"assets/1545881904150.png",alt:"1545881904150"}})]),n._v(" "),e("p",[n._v("打开工具窗口后，定位到当前CPP文件的盘符")]),n._v(" "),e("p",[n._v("然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名")]),n._v(" "),e("p",[n._v("效果如下图：")]),n._v(" "),e("p",[e("img",{attrs:{src:"assets/1545882158050.png",alt:"1545882158050"}})]),n._v(" "),e("blockquote",[e("p",[n._v("结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到")])]),n._v(" "),e("h4",{attrs:{id:"_4-6-4-继承中构造和析构顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-4-继承中构造和析构顺序"}},[n._v("#")]),n._v(" 4.6.4 继承中构造和析构顺序")]),n._v(" "),e("p",[n._v("子类继承父类后，当创建子类对象，也会调用父类的构造函数")]),n._v(" "),e("p",[n._v("问题：父类和子类的构造和析构顺序是谁先谁后？")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Base \n{\npublic:\n\tBase()\n\t{\n\t\tcout << "Base构造函数!" << endl;\n\t}\n\t~Base()\n\t{\n\t\tcout << "Base析构函数!" << endl;\n\t}\n};\n\nclass Son : public Base\n{\npublic:\n\tSon()\n\t{\n\t\tcout << "Son构造函数!" << endl;\n\t}\n\t~Son()\n\t{\n\t\tcout << "Son析构函数!" << endl;\n\t}\n\n};\n\n\nvoid test01()\n{\n\t//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\tSon s;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("blockquote",[e("p",[n._v("总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反")])]),n._v(" "),e("h4",{attrs:{id:"_4-6-5-继承同名成员处理方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-5-继承同名成员处理方式"}},[n._v("#")]),n._v(" 4.6.5 继承同名成员处理方式")]),n._v(" "),e("p",[n._v("问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？")]),n._v(" "),e("ul",[e("li",[n._v("访问子类同名成员   直接访问即可")]),n._v(" "),e("li",[n._v("访问父类同名成员   需要加作用域")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Base {\npublic:\n\tBase()\n\t{\n\t\tm_A = 100;\n\t}\n\n\tvoid func()\n\t{\n\t\tcout << "Base - func()调用" << endl;\n\t}\n\n\tvoid func(int a)\n\t{\n\t\tcout << "Base - func(int a)调用" << endl;\n\t}\n\npublic:\n\tint m_A;\n};\n\n\nclass Son : public Base {\npublic:\n\tSon()\n\t{\n\t\tm_A = 200;\n\t}\n\n\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\n\tvoid func()\n\t{\n\t\tcout << "Son - func()调用" << endl;\n\t}\npublic:\n\tint m_A;\n};\n\nvoid test01()\n{\n\tSon s;\n\n\tcout << "Son下的m_A = " << s.m_A << endl;\n\tcout << "Base下的m_A = " << s.Base::m_A << endl;\n\n\ts.func();\n\ts.Base::func();\n\ts.Base::func(10);\n\n}\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\treturn EXIT_SUCCESS;\n}\n')])])]),e("p",[n._v("总结：")]),n._v(" "),e("ol",[e("li",[n._v("子类对象可以直接访问到子类中同名成员")]),n._v(" "),e("li",[n._v("子类对象加作用域可以访问到父类同名成员")]),n._v(" "),e("li",[n._v("当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数")])]),n._v(" "),e("h4",{attrs:{id:"_4-6-6-继承同名静态成员处理方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-6-继承同名静态成员处理方式"}},[n._v("#")]),n._v(" 4.6.6 继承同名静态成员处理方式")]),n._v(" "),e("p",[n._v("问题：继承中同名的静态成员在子类对象上如何进行访问？")]),n._v(" "),e("p",[n._v("静态成员和非静态成员出现同名，处理方式一致")]),n._v(" "),e("ul",[e("li",[n._v("访问子类同名成员   直接访问即可")]),n._v(" "),e("li",[n._v("访问父类同名成员   需要加作用域")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << "Base - static void func()" << endl;\n\t}\n\tstatic void func(int a)\n\t{\n\t\tcout << "Base - static void func(int a)" << endl;\n\t}\n\n\tstatic int m_A;\n};\n\nint Base::m_A = 100;\n\nclass Son : public Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << "Son - static void func()" << endl;\n\t}\n\tstatic int m_A;\n};\n\nint Son::m_A = 200;\n\n//同名成员属性\nvoid test01()\n{\n\t//通过对象访问\n\tcout << "通过对象访问： " << endl;\n\tSon s;\n\tcout << "Son  下 m_A = " << s.m_A << endl;\n\tcout << "Base 下 m_A = " << s.Base::m_A << endl;\n\n\t//通过类名访问\n\tcout << "通过类名访问： " << endl;\n\tcout << "Son  下 m_A = " << Son::m_A << endl;\n\tcout << "Base 下 m_A = " << Son::Base::m_A << endl;\n}\n\n//同名成员函数\nvoid test02()\n{\n\t//通过对象访问\n\tcout << "通过对象访问： " << endl;\n\tSon s;\n\ts.func();\n\ts.Base::func();\n\n\tcout << "通过类名访问： " << endl;\n\tSon::func();\n\tSon::Base::func();\n\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\n\tSon::Base::func(100);\n}\nint main() {\n\n\t//test01();\n\ttest02();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("blockquote",[e("p",[n._v("总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）")])]),n._v(" "),e("h4",{attrs:{id:"_4-6-7-多继承语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-7-多继承语法"}},[n._v("#")]),n._v(" 4.6.7 多继承语法")]),n._v(" "),e("p",[n._v("C++允许"),e("strong",[n._v("一个类继承多个类")])]),n._v(" "),e("p",[n._v("语法："),e("code",[n._v("class 子类 ：继承方式 父类1 ， 继承方式 父类2...")])]),n._v(" "),e("p",[n._v("多继承可能会引发父类中有同名成员出现，需要加作用域区分")]),n._v(" "),e("p",[e("strong",[n._v("C++实际开发中不建议用多继承")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Base1 {\npublic:\n\tBase1()\n\t{\n\t\tm_A = 100;\n\t}\npublic:\n\tint m_A;\n};\n\nclass Base2 {\npublic:\n\tBase2()\n\t{\n\t\tm_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确\n\t}\npublic:\n\tint m_A;\n};\n\n//语法：class 子类：继承方式 父类1 ，继承方式 父类2 \nclass Son : public Base2, public Base1 \n{\npublic:\n\tSon()\n\t{\n\t\tm_C = 300;\n\t\tm_D = 400;\n\t}\npublic:\n\tint m_C;\n\tint m_D;\n};\n\n\n//多继承容易产生成员同名的情况\n//通过使用类名作用域可以区分调用哪一个基类的成员\nvoid test01()\n{\n\tSon s;\n\tcout << "sizeof Son = " << sizeof(s) << endl;\n\tcout << s.Base1::m_A << endl;\n\tcout << s.Base2::m_A << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("blockquote",[e("p",[n._v("总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域")])]),n._v(" "),e("h4",{attrs:{id:"_4-6-8-菱形继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-8-菱形继承"}},[n._v("#")]),n._v(" 4.6.8 菱形继承")]),n._v(" "),e("p",[e("strong",[n._v("菱形继承概念：")])]),n._v(" "),e("p",[n._v("​\t两个派生类继承同一个基类")]),n._v(" "),e("p",[n._v("​\t又有某个类同时继承者两个派生类")]),n._v(" "),e("p",[n._v("​\t这种继承被称为菱形继承，或者钻石继承")]),n._v(" "),e("p",[e("strong",[n._v("典型的菱形继承案例：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"assets/clip_image002.jpg",alt:"IMG_256"}})]),n._v(" "),e("p",[e("strong",[n._v("菱形继承问题：")])]),n._v(" "),e("ol",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n")])])])]),n._v(" "),e("li",[e("p",[n._v("草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。")])])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Animal\n{\npublic:\n\tint m_Age;\n};\n\n//继承前加virtual关键字后，变为虚继承\n//此时公共的父类Animal称为虚基类\nclass Sheep : virtual public Animal {};\nclass Tuo   : virtual public Animal {};\nclass SheepTuo : public Sheep, public Tuo {};\n\nvoid test01()\n{\n\tSheepTuo st;\n\tst.Sheep::m_Age = 100;\n\tst.Tuo::m_Age = 200;\n\n\tcout << "st.Sheep::m_Age = " << st.Sheep::m_Age << endl;\n\tcout << "st.Tuo::m_Age = " <<  st.Tuo::m_Age << endl;\n\tcout << "st.m_Age = " << st.m_Age << endl;\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("总结：")]),n._v(" "),e("ul",[e("li",[n._v("菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义")]),n._v(" "),e("li",[n._v("利用虚继承可以解决菱形继承问题")])]),n._v(" "),e("h3",{attrs:{id:"_4-7-多态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-多态"}},[n._v("#")]),n._v(" 4.7  多态")]),n._v(" "),e("h4",{attrs:{id:"_4-7-1-多态的基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-1-多态的基本概念"}},[n._v("#")]),n._v(" 4.7.1 多态的基本概念")]),n._v(" "),e("p",[e("strong",[n._v("多态是C++面向对象三大特性之一")])]),n._v(" "),e("p",[n._v("多态分为两类")]),n._v(" "),e("ul",[e("li",[n._v("静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名")]),n._v(" "),e("li",[n._v("动态多态: 派生类和虚函数实现运行时多态")])]),n._v(" "),e("p",[n._v("静态多态和动态多态区别：")]),n._v(" "),e("ul",[e("li",[n._v("静态多态的函数地址早绑定  -  编译阶段确定函数地址")]),n._v(" "),e("li",[n._v("动态多态的函数地址晚绑定  -  运行阶段确定函数地址")])]),n._v(" "),e("p",[n._v("下面通过案例进行讲解多态")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Animal\n{\npublic:\n\t//Speak函数就是虚函数\n\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\n\tvirtual void speak()\n\t{\n\t\tcout << "动物在说话" << endl;\n\t}\n};\n\nclass Cat :public Animal\n{\npublic:\n\tvoid speak()\n\t{\n\t\tcout << "小猫在说话" << endl;\n\t}\n};\n\nclass Dog :public Animal\n{\npublic:\n\n\tvoid speak()\n\t{\n\t\tcout << "小狗在说话" << endl;\n\t}\n\n};\n//我们希望传入什么对象，那么就调用什么对象的函数\n//如果函数地址在编译阶段就能确定，那么静态联编\n//如果函数地址在运行阶段才能确定，就是动态联编\n\nvoid DoSpeak(Animal & animal)\n{\n\tanimal.speak();\n}\n//\n//多态满足条件： \n//1、有继承关系\n//2、子类重写父类中的虚函数\n//多态使用：\n//父类指针或引用指向子类对象\n\nvoid test01()\n{\n\tCat cat;\n\tDoSpeak(cat);\n\n\n\tDog dog;\n\tDoSpeak(dog);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("总结：")]),n._v(" "),e("p",[n._v("多态满足条件")]),n._v(" "),e("ul",[e("li",[n._v("有继承关系")]),n._v(" "),e("li",[n._v("子类重写父类中的虚函数")])]),n._v(" "),e("p",[n._v("多态使用条件")]),n._v(" "),e("ul",[e("li",[n._v("父类指针或引用指向子类对象")])]),n._v(" "),e("p",[n._v("重写：函数返回值类型  函数名 参数列表 完全一致称为重写")]),n._v(" "),e("h4",{attrs:{id:"_4-7-2-多态案例一-计算器类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-2-多态案例一-计算器类"}},[n._v("#")]),n._v(" 4.7.2 多态案例一-计算器类")]),n._v(" "),e("p",[n._v("案例描述：")]),n._v(" "),e("p",[n._v("分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类")]),n._v(" "),e("p",[n._v("多态的优点：")]),n._v(" "),e("ul",[e("li",[n._v("代码组织结构清晰")]),n._v(" "),e("li",[n._v("可读性强")]),n._v(" "),e("li",[n._v("利于前期和后期的扩展以及维护")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//普通实现\nclass Calculator {\npublic:\n\tint getResult(string oper)\n\t{\n\t\tif (oper == "+") {\n\t\t\treturn m_Num1 + m_Num2;\n\t\t}\n\t\telse if (oper == "-") {\n\t\t\treturn m_Num1 - m_Num2;\n\t\t}\n\t\telse if (oper == "*") {\n\t\t\treturn m_Num1 * m_Num2;\n\t\t}\n\t\t//如果要提供新的运算，需要修改源码\n\t}\npublic:\n\tint m_Num1;\n\tint m_Num2;\n};\n\nvoid test01()\n{\n\t//普通实现测试\n\tCalculator c;\n\tc.m_Num1 = 10;\n\tc.m_Num2 = 10;\n\tcout << c.m_Num1 << " + " << c.m_Num2 << " = " << c.getResult("+") << endl;\n\n\tcout << c.m_Num1 << " - " << c.m_Num2 << " = " << c.getResult("-") << endl;\n\n\tcout << c.m_Num1 << " * " << c.m_Num2 << " = " << c.getResult("*") << endl;\n}\n                  \n    \n\n//多态实现\n//抽象计算器类\n//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护\nclass AbstractCalculator\n{\npublic :\n\n\tvirtual int getResult()\n\t{\n\t\treturn 0;\n\t}\n\n\tint m_Num1;\n\tint m_Num2;\n};\n\n//加法计算器\nclass AddCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 + m_Num2;\n\t}\n};\n\n//减法计算器\nclass SubCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 - m_Num2;\n\t}\n};\n\n//乘法计算器\nclass MulCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 * m_Num2;\n\t}\n};\n\n\nvoid test02()\n{\n\t//创建加法计算器\n\tAbstractCalculator *abc = new AddCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << " + " << abc->m_Num2 << " = " << abc->getResult() << endl;\n\tdelete abc;  //用完了记得销毁\n\n\t//创建减法计算器\n\tabc = new SubCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << " - " << abc->m_Num2 << " = " << abc->getResult() << endl;\n\tdelete abc;  \n\n\t//创建乘法计算器\n\tabc = new MulCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << " * " << abc->m_Num2 << " = " << abc->getResult() << endl;\n\tdelete abc;\n}\n\nint main() {\n\n\t//test01();\n\n\ttest02();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("blockquote",[e("p",[n._v("总结：C++开发提倡利用多态设计程序架构，因为多态优点很多")])]),n._v(" "),e("h4",{attrs:{id:"_4-7-3-纯虚函数和抽象类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-3-纯虚函数和抽象类"}},[n._v("#")]),n._v(" 4.7.3 纯虚函数和抽象类")]),n._v(" "),e("p",[n._v("在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容")]),n._v(" "),e("p",[n._v("因此可以将虚函数改为"),e("strong",[n._v("纯虚函数")])]),n._v(" "),e("p",[n._v("纯虚函数语法："),e("code",[n._v("virtual 返回值类型 函数名 （参数列表）= 0 ;")])]),n._v(" "),e("p",[n._v("当类中有了纯虚函数，这个类也称为==抽象类==")]),n._v(" "),e("p",[e("strong",[n._v("抽象类特点")]),n._v("：")]),n._v(" "),e("ul",[e("li",[n._v("无法实例化对象")]),n._v(" "),e("li",[n._v("子类必须重写抽象类中的纯虚函数，否则也属于抽象类")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Base\n{\npublic:\n\t//纯虚函数\n\t//类中只要有一个纯虚函数就称为抽象类\n\t//抽象类无法实例化对象\n\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\n\tvirtual void func() = 0;\n};\n\nclass Son :public Base\n{\npublic:\n\tvirtual void func() \n\t{\n\t\tcout << "func调用" << endl;\n\t};\n};\n\nvoid test01()\n{\n\tBase * base = NULL;\n\t//base = new Base; // 错误，抽象类无法实例化对象\n\tbase = new Son;\n\tbase->func();\n\tdelete base;//记得销毁\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-7-4-多态案例二-制作饮品"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-4-多态案例二-制作饮品"}},[n._v("#")]),n._v(" 4.7.4 多态案例二-制作饮品")]),n._v(" "),e("p",[e("strong",[n._v("案例描述：")])]),n._v(" "),e("p",[n._v("制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料")]),n._v(" "),e("p",[n._v("利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶")]),n._v(" "),e("p",[e("img",{attrs:{src:"assets/1545985945198.png",alt:"1545985945198"}})]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//抽象制作饮品\nclass AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() = 0;\n\t//冲泡\n\tvirtual void Brew() = 0;\n\t//倒入杯中\n\tvirtual void PourInCup() = 0;\n\t//加入辅料\n\tvirtual void PutSomething() = 0;\n\t//规定流程\n\tvoid MakeDrink() {\n\t\tBoil();\n\t\tBrew();\n\t\tPourInCup();\n\t\tPutSomething();\n\t}\n};\n\n//制作咖啡\nclass Coffee : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << "煮农夫山泉!" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << "冲泡咖啡!" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << "将咖啡倒入杯中!" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << "加入牛奶!" << endl;\n\t}\n};\n\n//制作茶水\nclass Tea : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << "煮自来水!" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << "冲泡茶叶!" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << "将茶水倒入杯中!" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << "加入枸杞!" << endl;\n\t}\n};\n\n//业务函数\nvoid DoWork(AbstractDrinking* drink) {\n\tdrink->MakeDrink();\n\tdelete drink;\n}\n\nvoid test01() {\n\tDoWork(new Coffee);\n\tcout << "--------------" << endl;\n\tDoWork(new Tea);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("h4",{attrs:{id:"_4-7-5-虚析构和纯虚析构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-5-虚析构和纯虚析构"}},[n._v("#")]),n._v(" 4.7.5 虚析构和纯虚析构")]),n._v(" "),e("p",[n._v("多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码")]),n._v(" "),e("p",[n._v("解决方式：将父类中的析构函数改为"),e("strong",[n._v("虚析构")]),n._v("或者"),e("strong",[n._v("纯虚析构")])]),n._v(" "),e("p",[n._v("虚析构和纯虚析构共性：")]),n._v(" "),e("ul",[e("li",[n._v("可以解决父类指针释放子类对象")]),n._v(" "),e("li",[n._v("都需要有具体的函数实现")])]),n._v(" "),e("p",[n._v("虚析构和纯虚析构区别：")]),n._v(" "),e("ul",[e("li",[n._v("如果是纯虚析构，该类属于抽象类，无法实例化对象")])]),n._v(" "),e("p",[n._v("虚析构语法：")]),n._v(" "),e("p",[e("code",[n._v("virtual ~类名(){}")])]),n._v(" "),e("p",[n._v("纯虚析构语法：")]),n._v(" "),e("p",[e("code",[n._v("virtual ~类名() = 0;")])]),n._v(" "),e("p",[e("code",[n._v("类名::~类名(){}")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('class Animal {\npublic:\n\n\tAnimal()\n\t{\n\t\tcout << "Animal 构造函数调用！" << endl;\n\t}\n\tvirtual void Speak() = 0;\n\n\t//析构函数加上virtual关键字，变成虚析构函数\n\t//virtual ~Animal()\n\t//{\n\t//\tcout << "Animal虚析构函数调用！" << endl;\n\t//}\n\n\n\tvirtual ~Animal() = 0;\n};\n\nAnimal::~Animal()\n{\n\tcout << "Animal 纯虚析构函数调用！" << endl;\n}\n\n//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。\n\nclass Cat : public Animal {\npublic:\n\tCat(string name)\n\t{\n\t\tcout << "Cat构造函数调用！" << endl;\n\t\tm_Name = new string(name);\n\t}\n\tvirtual void Speak()\n\t{\n\t\tcout << *m_Name <<  "小猫在说话!" << endl;\n\t}\n\t~Cat()\n\t{\n\t\tcout << "Cat析构函数调用!" << endl;\n\t\tif (this->m_Name != NULL) {\n\t\t\tdelete m_Name;\n\t\t\tm_Name = NULL;\n\t\t}\n\t}\n\npublic:\n\tstring *m_Name;\n};\n\nvoid test01()\n{\n\tAnimal *animal = new Cat("Tom");\n\tanimal->Speak();\n\n\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n\t//怎么解决？给基类增加一个虚析构函数\n\t//虚析构函数就是用来解决通过父类指针释放子类对象\n\tdelete animal;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("总结：")]),n._v(" "),e("p",[n._v("​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象")]),n._v(" "),e("p",[n._v("​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构")]),n._v(" "),e("p",[n._v("​\t3. 拥有纯虚析构函数的类也属于抽象")]),n._v(" "),e("h4",{attrs:{id:"_4-7-6-多态案例三-电脑组装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-6-多态案例三-电脑组装"}},[n._v("#")]),n._v(" 4.7.6 多态案例三-电脑组装")]),n._v(" "),e("p",[e("strong",[n._v("案例描述：")])]),n._v(" "),e("p",[n._v("电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）")]),n._v(" "),e("p",[n._v("将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商")]),n._v(" "),e("p",[n._v("创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口")]),n._v(" "),e("p",[n._v("测试时组装三台不同的电脑进行工作")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include<iostream>\nusing namespace std;\n\n//抽象CPU类\nclass CPU\n{\npublic:\n\t//抽象的计算函数\n\tvirtual void calculate() = 0;\n};\n\n//抽象显卡类\nclass VideoCard\n{\npublic:\n\t//抽象的显示函数\n\tvirtual void display() = 0;\n};\n\n//抽象内存条类\nclass Memory\n{\npublic:\n\t//抽象的存储函数\n\tvirtual void storage() = 0;\n};\n\n//电脑类\nclass Computer\n{\npublic:\n\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\n\t{\n\t\tm_cpu = cpu;\n\t\tm_vc = vc;\n\t\tm_mem = mem;\n\t}\n\n\t//提供工作的函数\n\tvoid work()\n\t{\n\t\t//让零件工作起来，调用接口\n\t\tm_cpu->calculate();\n\n\t\tm_vc->display();\n\n\t\tm_mem->storage();\n\t}\n\n\t//提供析构函数 释放3个电脑零件\n\t~Computer()\n\t{\n\n\t\t//释放CPU零件\n\t\tif (m_cpu != NULL)\n\t\t{\n\t\t\tdelete m_cpu;\n\t\t\tm_cpu = NULL;\n\t\t}\n\n\t\t//释放显卡零件\n\t\tif (m_vc != NULL)\n\t\t{\n\t\t\tdelete m_vc;\n\t\t\tm_vc = NULL;\n\t\t}\n\n\t\t//释放内存条零件\n\t\tif (m_mem != NULL)\n\t\t{\n\t\t\tdelete m_mem;\n\t\t\tm_mem = NULL;\n\t\t}\n\t}\n\nprivate:\n\n\tCPU * m_cpu; //CPU的零件指针\n\tVideoCard * m_vc; //显卡零件指针\n\tMemory * m_mem; //内存条零件指针\n};\n\n//具体厂商\n//Intel厂商\nclass IntelCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << "Intel的CPU开始计算了！" << endl;\n\t}\n};\n\nclass IntelVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << "Intel的显卡开始显示了！" << endl;\n\t}\n};\n\nclass IntelMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << "Intel的内存条开始存储了！" << endl;\n\t}\n};\n\n//Lenovo厂商\nclass LenovoCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << "Lenovo的CPU开始计算了！" << endl;\n\t}\n};\n\nclass LenovoVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << "Lenovo的显卡开始显示了！" << endl;\n\t}\n};\n\nclass LenovoMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << "Lenovo的内存条开始存储了！" << endl;\n\t}\n};\n\n\nvoid test01()\n{\n\t//第一台电脑零件\n\tCPU * intelCpu = new IntelCPU;\n\tVideoCard * intelCard = new IntelVideoCard;\n\tMemory * intelMem = new IntelMemory;\n\n\tcout << "第一台电脑开始工作：" << endl;\n\t//创建第一台电脑\n\tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\n\tcomputer1->work();\n\tdelete computer1;\n\n\tcout << "-----------------------" << endl;\n\tcout << "第二台电脑开始工作：" << endl;\n\t//第二台电脑组装\n\tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\n\tcomputer2->work();\n\tdelete computer2;\n\n\tcout << "-----------------------" << endl;\n\tcout << "第三台电脑开始工作：" << endl;\n\t//第三台电脑组装\n\tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\n\tcomputer3->work();\n\tdelete computer3;\n\n}\n')])])]),e("h2",{attrs:{id:"_5-文件操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-文件操作"}},[n._v("#")]),n._v(" 5 文件操作")]),n._v(" "),e("p",[n._v("程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放")]),n._v(" "),e("p",[n._v("通过"),e("strong",[n._v("文件可以将数据持久化")])]),n._v(" "),e("p",[n._v("C++中对文件操作需要包含头文件 ==< fstream >==")]),n._v(" "),e("p",[n._v("文件类型分为两种：")]),n._v(" "),e("ol",[e("li",[e("strong",[n._v("文本文件")]),n._v("     -  文件以文本的"),e("strong",[n._v("ASCII码")]),n._v("形式存储在计算机中")]),n._v(" "),e("li",[e("strong",[n._v("二进制文件")]),n._v(" -  文件以文本的"),e("strong",[n._v("二进制")]),n._v("形式存储在计算机中，用户一般不能直接读懂它们")])]),n._v(" "),e("p",[n._v("操作文件的三大类:")]),n._v(" "),e("ol",[e("li",[n._v("ofstream：写操作")]),n._v(" "),e("li",[n._v("ifstream： 读操作")]),n._v(" "),e("li",[n._v("fstream ： 读写操作")])]),n._v(" "),e("h3",{attrs:{id:"_5-1文本文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-1文本文件"}},[n._v("#")]),n._v(" 5.1文本文件")]),n._v(" "),e("h4",{attrs:{id:"_5-1-1写文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1写文件"}},[n._v("#")]),n._v(" 5.1.1写文件")]),n._v(" "),e("p",[n._v("写文件步骤如下：")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("包含头文件")]),n._v(" "),e("p",[n._v("#include <fstream>")])]),n._v(" "),e("li",[e("p",[n._v("创建流对象")]),n._v(" "),e("p",[n._v("ofstream ofs;")])]),n._v(" "),e("li",[e("p",[n._v("打开文件")]),n._v(" "),e("p",[n._v('ofs.open("文件路径",打开方式);')])]),n._v(" "),e("li",[e("p",[n._v("写数据")]),n._v(" "),e("p",[n._v('ofs << "写入的数据";')])]),n._v(" "),e("li",[e("p",[n._v("关闭文件")]),n._v(" "),e("p",[n._v("ofs.close();")])])]),n._v(" "),e("p",[n._v("文件打开方式：")]),n._v(" "),e("table",[e("thead",[e("tr",[e("th",[n._v("打开方式")]),n._v(" "),e("th",[n._v("解释")])])]),n._v(" "),e("tbody",[e("tr",[e("td",[n._v("ios::in")]),n._v(" "),e("td",[n._v("为读文件而打开文件")])]),n._v(" "),e("tr",[e("td",[n._v("ios::out")]),n._v(" "),e("td",[n._v("为写文件而打开文件")])]),n._v(" "),e("tr",[e("td",[n._v("ios::ate")]),n._v(" "),e("td",[n._v("初始位置：文件尾")])]),n._v(" "),e("tr",[e("td",[n._v("ios::app")]),n._v(" "),e("td",[n._v("追加方式写文件")])]),n._v(" "),e("tr",[e("td",[n._v("ios::trunc")]),n._v(" "),e("td",[n._v("如果文件存在先删除，再创建")])]),n._v(" "),e("tr",[e("td",[n._v("ios::binary")]),n._v(" "),e("td",[n._v("二进制方式")])])])]),n._v(" "),e("p",[e("strong",[n._v("注意：")]),n._v(" 文件打开方式可以配合使用，利用|操作符")]),n._v(" "),e("p",[n._v("**例如：**用二进制方式写文件 "),e("code",[n._v("ios::binary | ios:: out")])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <fstream>\n\nvoid test01()\n{\n\tofstream ofs;\n\tofs.open("test.txt", ios::out);\n\n\tofs << "姓名：张三" << endl;\n\tofs << "性别：男" << endl;\n\tofs << "年龄：18" << endl;\n\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("总结：")]),n._v(" "),e("ul",[e("li",[n._v("文件操作必须包含头文件 fstream")]),n._v(" "),e("li",[n._v("读文件可以利用 ofstream  ，或者fstream类")]),n._v(" "),e("li",[n._v("打开文件时候需要指定操作文件的路径，以及打开方式")]),n._v(" "),e("li",[n._v("利用<<可以向文件中写数据")]),n._v(" "),e("li",[n._v("操作完毕，要关闭文件")])]),n._v(" "),e("h4",{attrs:{id:"_5-1-2读文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-2读文件"}},[n._v("#")]),n._v(" 5.1.2读文件")]),n._v(" "),e("p",[n._v("读文件与写文件步骤相似，但是读取方式相对于比较多")]),n._v(" "),e("p",[n._v("读文件步骤如下：")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("包含头文件")]),n._v(" "),e("p",[n._v("#include <fstream>")])]),n._v(" "),e("li",[e("p",[n._v("创建流对象")]),n._v(" "),e("p",[n._v("ifstream ifs;")])]),n._v(" "),e("li",[e("p",[n._v("打开文件并判断文件是否打开成功")]),n._v(" "),e("p",[n._v('ifs.open("文件路径",打开方式);')])]),n._v(" "),e("li",[e("p",[n._v("读数据")]),n._v(" "),e("p",[n._v("四种方式读取")])]),n._v(" "),e("li",[e("p",[n._v("关闭文件")]),n._v(" "),e("p",[n._v("ifs.close();")])])]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <fstream>\n#include <string>\nvoid test01()\n{\n\tifstream ifs;\n\tifs.open("test.txt", ios::in);\n\n\tif (!ifs.is_open())\n\t{\n\t\tcout << "文件打开失败" << endl;\n\t\treturn;\n\t}\n\n\t//第一种方式\n\t//char buf[1024] = { 0 };\n\t//while (ifs >> buf)\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第二种\n\t//char buf[1024] = { 0 };\n\t//while (ifs.getline(buf,sizeof(buf)))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第三种\n\t//string buf;\n\t//while (getline(ifs, buf))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\tchar c;\n\twhile ((c = ifs.get()) != EOF)\n\t{\n\t\tcout << c;\n\t}\n\n\tifs.close();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("总结：")]),n._v(" "),e("ul",[e("li",[n._v("读文件可以利用 ifstream  ，或者fstream类")]),n._v(" "),e("li",[n._v("利用is_open函数可以判断文件是否打开成功")]),n._v(" "),e("li",[n._v("close 关闭文件")])]),n._v(" "),e("h3",{attrs:{id:"_5-2-二进制文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-二进制文件"}},[n._v("#")]),n._v(" 5.2 二进制文件")]),n._v(" "),e("p",[n._v("以二进制的方式对文件进行读写操作")]),n._v(" "),e("p",[n._v("打开方式要指定为 ==ios::binary==")]),n._v(" "),e("h4",{attrs:{id:"_5-2-1-写文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-写文件"}},[n._v("#")]),n._v(" 5.2.1 写文件")]),n._v(" "),e("p",[n._v("二进制方式写文件主要利用流对象调用成员函数write")]),n._v(" "),e("p",[n._v("函数原型 ："),e("code",[n._v("ostream& write(const char * buffer,int len);")])]),n._v(" "),e("p",[n._v("参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\n//二进制文件  写文件\nvoid test01()\n{\n\t//1、包含头文件\n\n\t//2、创建输出流对象\n\tofstream ofs("person.txt", ios::out | ios::binary);\n\t\n\t//3、打开文件\n\t//ofs.open("person.txt", ios::out | ios::binary);\n\n\tPerson p = {"张三"  , 18};\n\n\t//4、写文件\n\tofs.write((const char *)&p, sizeof(p));\n\n\t//5、关闭文件\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("p",[n._v("总结：")]),n._v(" "),e("ul",[e("li",[n._v("文件输出流对象 可以通过write函数，以二进制方式写数据")])]),n._v(" "),e("h4",{attrs:{id:"_5-2-2-读文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-2-读文件"}},[n._v("#")]),n._v(" 5.2.2 读文件")]),n._v(" "),e("p",[n._v("二进制方式读文件主要利用流对象调用成员函数read")]),n._v(" "),e("p",[n._v("函数原型："),e("code",[n._v("istream& read(char *buffer,int len);")])]),n._v(" "),e("p",[n._v("参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数")]),n._v(" "),e("p",[n._v("示例：")]),n._v(" "),e("div",{staticClass:"language-C++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\nvoid test01()\n{\n\tifstream ifs("person.txt", ios::in | ios::binary);\n\tif (!ifs.is_open())\n\t{\n\t\tcout << "文件打开失败" << endl;\n\t}\n\n\tPerson p;\n\tifs.read((char *)&p, sizeof(p));\n\n\tcout << "姓名： " << p.m_Name << " 年龄： " << p.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem("pause");\n\n\treturn 0;\n}\n')])])]),e("ul",[e("li",[n._v("文件输入流对象 可以通过read函数，以二进制方式读数据")])]),n._v(" "),e("h2",{attrs:{id:"_6-练习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-练习"}},[n._v("#")]),n._v(" 6 练习")]),n._v(" "),e("p",[n._v("1、string库字符操作")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('package main\n\n\nimport (\n\t"context"\n\t"flag"\n\t"fmt"\n\t"google.golang.org/grpc"\n\t"google.golang.org/grpc/metadata"\n\t"io"\n\tpb "learn-plus/grpc/proto"\n\t"log"\n\t"sync"\n\t"time"\n)\n\nvar addr = flag.String("addr", "localhost:50055", "the address to connect to")\n\nconst (\n\ttimestampFormat = time.StampNano // "Jan _2 15:04:05.000"\n\tstreamingCount  = 10\n\tAccessToken="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1ODk2OTExMTQsImlzcyI6ImFwcF9pZF9iIn0.qb2A_WsDP_-jfQBxJk6L57gTnAzZs-SPLMSS_UO6Gkc"\n)\n\nfunc unaryCallWithMetadata(c pb.EchoClient, message string) {\n\tfmt.Printf("--- unary ---\\n")\n\n\t// Create metadata and context.\n\tmd := metadata.Pairs("timestamp", time.Now().Format(timestampFormat))\n\tmd.Append("authorization", "Bearer "+AccessToken)\n\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tr, err := c.UnaryEcho(ctx, &pb.EchoRequest{Message: message})\n\tif err != nil {\n\t\tlog.Fatalf("failed to call UnaryEcho: %v", err)\n\t}\n\tfmt.Printf("response:%v\\n", r.Message)\n}\n\nfunc serverStreamingWithMetadata(c pb.EchoClient, message string) {\n\tfmt.Printf("--- server streaming ---\\n")\n\n\tmd := metadata.Pairs("timestamp", time.Now().Format(timestampFormat))\n\tmd.Append("authorization", "Bearer "+AccessToken)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\n\tstream, err := c.ServerStreamingEcho(ctx, &pb.EchoRequest{Message: message})\n\tif err != nil {\n\t\tlog.Fatalf("failed to call ServerStreamingEcho: %v", err)\n\t}\n\n\t// Read all the responses.\n\tvar rpcStatus error\n\tfmt.Printf("response:\\n")\n\tfor {\n\t\tr, err := stream.Recv()\n\t\tif err != nil {\n\t\t\trpcStatus = err\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(" - %s\\n", r.Message)\n\t}\n\tif rpcStatus != io.EOF {\n\t\tlog.Fatalf("failed to finish server streaming: %v", rpcStatus)\n\t}\n}\n\nfunc clientStreamWithMetadata(c pb.EchoClient, message string) {\n\tfmt.Printf("--- client streaming ---\\n")\n\tmd := metadata.Pairs("timestamp", time.Now().Format(timestampFormat))\n\tmd.Append("authorization", "Bearer "+AccessToken)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tstream, err := c.ClientStreamingEcho(ctx)\n\tif err != nil {\n\t\tlog.Fatalf("failed to call ClientStreamingEcho: %v\\n", err)\n\t}\n\n\t// Send all requests to the server.\n\tfor i := 0; i < streamingCount; i++ {\n\t\tif err := stream.Send(&pb.EchoRequest{Message: message}); err != nil {\n\t\t\tlog.Fatalf("failed to send streaming: %v\\n", err)\n\t\t}\n\t}\n\n\t// Read the response.\n\tr, err := stream.CloseAndRecv()\n\tif err != nil {\n\t\tlog.Fatalf("failed to CloseAndRecv: %v\\n", err)\n\t}\n\tfmt.Printf("response:%v\\n", r.Message)\n}\n\nfunc bidirectionalWithMetadata(c pb.EchoClient, message string) {\n\tfmt.Printf("--- bidirectional ---\\n")\n\tmd := metadata.Pairs("timestamp", time.Now().Format(timestampFormat))\n\tmd.Append("authorization", "Bearer "+AccessToken)\n\tctx := metadata.NewOutgoingContext(context.Background(), md)\n\tstream, err := c.BidirectionalStreamingEcho(ctx)\n\tif err != nil {\n\t\tlog.Fatalf("failed to call BidirectionalStreamingEcho: %v\\n", err)\n\t}\n\n\tgo func() {\n\t\t// Send all requests to the server.\n\t\tfor i := 0; i < streamingCount; i++ {\n\t\t\tif err := stream.Send(&pb.EchoRequest{Message: message}); err != nil {\n\t\t\t\tlog.Fatalf("failed to send streaming: %v\\n", err)\n\t\t\t}\n\t\t}\n\t\tstream.CloseSend()\n\t}()\n\n\t// Read all the responses.\n\tvar rpcStatus error\n\tfmt.Printf("response:\\n")\n\tfor {\n\t\tr, err := stream.Recv()\n\t\tif err != nil {\n\t\t\trpcStatus = err\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(" - %s\\n", r.Message)\n\t}\n\tif rpcStatus != io.EOF {\n\t\tlog.Fatalf("failed to finish server streaming: %v", rpcStatus)\n\t}\n}\n\nconst message = "this is examples/metadata"\n\nfunc main() {\n\tflag.Parse()\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < 1; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tconn, err := grpc.Dial(*addr, grpc.WithInsecure())\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf("did not connect: %v", err)\n\t\t\t}\n\t\t\tdefer conn.Close()\n\n\t\t\tc := pb.NewEchoClient(conn)\n\n\t\t\t//调用一元方法\n\t\t\t//for i := 0; i < 100; i++ {\n\t\t\tunaryCallWithMetadata(c, message)\n\t\t\ttime.Sleep(400 * time.Millisecond)\n\t\t\t//}\n\t\t\t//\n\t\t\t//服务端流式\n\t\t\tserverStreamingWithMetadata(c, message)\n\t\t\ttime.Sleep(1 * time.Second)\n\n\t\t\t//客户端流式\n\t\t\tclientStreamWithMetadata(c, message)\n\t\t\ttime.Sleep(1 * time.Second)\n\n\t\t\t//双向流式\n\t\t\tbidirectionalWithMetadata(c, message)\n\t\t}()\n\t}\n\twg.Wait()\n\ttime.Sleep(1 * time.Second)\n}\n')])])]),e("p",[n._v("2、指针和数组")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include<iostream>\nusing namespace std;\n\nvoid test01()\n{\n    int* p;\n    int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };\n\n    // 打印测试数组：\n    cout << "输入的数组为：" << endl;\n    for (int i = 0; i < 10; i++)\n    {\n        cout << arr[i] << "  ";  // 1  2  3  4  5  6  7  8  9  10\n    }\n\n    // 将数组的首地址 赋值给 p 指针\n    p = arr;\n    cout << endl << endl << "p = arr" << endl;\n    cout << "输入的数组为（使用了指针操作）：" << endl;\n    for (int i = 0; i < 10; i++)\n    {\n        cout << *(p + i) << "  ";  // 1  2  3  4  5  6  7  8  9  10\n    }\n\n\n    // 利用++，将指针指向的地址进行++操作，及对数组的赋值\n    p++;  // 此时 p 指向的是 arr[1] 的 地址，而不是 arr[0]\n    cout << endl << endl << "p++   <---- 使用的操作" << endl;\n    cout << "输入的数组为（使用了指针地址++操作）：" << endl;\n    for (int i = 0; i < 10; i++)\n    {\n        cout << *(p + i) << "  ";  // 2  3  4  5  6  7  8  9  10  2057764875\n    }\n\n    p = &arr[7];  // 此时 p 指向的是 arr[7] 的 地址，注意加 “&”\n    *p = 66;\n    cout << endl << endl << "p = &arr[7]\t  *p = 66   <---- 使用的操作" << endl;\n\n    cout << "*(p + i) 循环 :" ;\n    for (int i = 0; i < 10; i++)\n    {\n        cout <<  *(p + i) << "  ";  // 66  9  10  2057764875  -1855373196  -520394320  32766  247771284  1  -520394296\n    }\n\n    cout << endl << "arr[i] 循环 :";\n    for (int i = 0; i < 10; i++)\n    {\n        cout <<arr[i] << "  ";\n    }\n\n\n    cout << endl << endl << "这个地方可能会崩掉，是编译器的问题，但命令窗中的结果是对的！----\x3e";\n\n    *(p + 4) = 233;\n    cout << endl << endl << "*(p + 4) = 233   <---- 使用的操作" << endl;\n    cout << "*(p + i) 循环 :";\n    for (int i = 0; i < 13; i++)\n    {\n        cout << *(p + i) << "  ";\n    }\n\n    cout << endl << "arr[i] 循环 :";\n\n\n    for (int i = 0; i < 13; i++)\n    {\n        cout << arr[i] << "  ";\n    }// 这个地方可能会崩掉，是编译器的问题，但命令窗中的结果是对的！\n\n\n\n    int len = p - arr;\n    cout << endl << endl << "int len = p - arr   p = &arr[7]  <---- 使用的操作" << endl;\n    cout << "p 此时的地址：" << p << endl;  // p 此时的地址：0x7ffee0fb697c\n    cout << "arr 此时的地址：" << arr << endl;  // arr 此时的地址：0x7ffee0fb6960\n    cout << "len = p - arr = " << len << endl;// 7\n\n}\n\nint main()\n{\n    test01();\n    return 0;\n}\n')])])]),e("p",[n._v("3、数组和指针实现strconv")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#include<iostream>\nusing namespace std;\n\n\n// strchr() 函数：查找字符在字符串中首次出现的位置。一般用于 char 类型数组\nvoid fun_strchr()\n{\n\tchar arr[] = \"hello world\";\n\tchar ch = 'o';\n\n\tchar* p = strchr(arr, ch);\n\n\tcout << p << endl;\n}\n\n\n// 使用数组实现\nchar* myStrchr(char* arr, char ch)\n{\n\tint i = 0;\n\twhile (arr[i] != '\\0')\n\t{\n\t\tif (arr[i] == ch)\n\t\t{\n\t\t\treturn &arr[i];\n\t\t}\n\t\ti++;\n\t}\n\treturn NULL;\n}\n\n\n// 使用数组实现\nchar* myStrchr_p(char* arr, char ch)\n{\n\tchar* p = arr;\n\twhile (*p != '\\0')\n\t{\n\t\tif (*p == ch)\n\t\t{\n\t\t\treturn p;\n\t\t}\n\t\tp++;\n\t}\n\treturn NULL;\n}\n\n\nint main()\n{\n\tchar arr[] = \"hello world\";\n\tchar ch = 'o';\n\n\tcout << arr << endl;  // hello world\n \n\tcout << myStrchr_p(arr,ch);  //o world\n\t\n\t//cout << myStrchr(arr,ch);\n\t// fun_strchr();\n}\n")])])]),e("p",[n._v("4、字符反转")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include<iostream>\nusing namespace std;\n\nchar* rec(char* arr)\n{\n\tint len = strlen(arr);\n\tcout << "×Ö·û´®µÄ³¤¶ÈÎª£º" << len << endl;\t\n\t\n\tchar* p_1 = arr;\n\tchar* p_end = &arr[len - 1];\n\twhile (p_1 < p_end)\n\t{\n\t\tchar temp;\n\t\ttemp = *p_1;\n\t\t*p_1 = *p_end;\n\t\t*p_end = temp;\n\t\tp_1++;\n\t\tp_end--;\n\t}\n\treturn arr;\n}\n\nint main()\n{\n\tchar arr[] = "Hello world";\n\tcout << arr << endl;\n\tcout << rec(arr);\n}\n')])])]),e("p",[n._v("5、多级指针")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('#include<iostream>\nusing namespace std;\n\n// 几级指针就有几个“ * ”\n\nvoid p_LV2()\n{\n    int t = 10;\n    cout << "t = " << t << endl << endl;\n\n    int* p = &t;\n    cout << "p = " << p << endl;  //p = 0x7ffeea82499c\n    cout << "*p = " << *p << endl << endl;  // *p = 10\n\n    int** pp = &p;\n    cout << "int** p = &p" << endl;\n    cout << "&p = " << &p << endl; // &p = 0x7ffee8412990\n    cout << "pp = " << pp << endl; // 一级指针的地址 pp = 0x7ffee8412990\n    cout << "*pp = " << *pp << endl; //一级指针的储存的值，也就是 t 的地址 *pp = p = &t *pp = 0x7ffee841299c\n    cout << "**pp = " << **pp << endl; // 一级指针储存地址的值，也就是 t 的值 **pp = 10\n}\n\n\nvoid p_LV3()\n{\n    int t = 10;\n    cout << "t = " << t << endl << endl;\n\n    int* p = &t;\n    cout << "p = " << p << endl; // p = 0x7ffeea82499c\n    cout << "*p = " << *p << endl << endl;  // *p = 10\n\n    int** pp = &p;\n    cout << "int** p = &p" << endl;\n    cout << "&p = " << &p << endl;  // &p = 0x7ffeea824990\n    cout << "pp = " << pp << endl; // 一级指针的地址 pp = 0x7ffeea824990\n    cout << "*pp = " << *pp << endl; //一级指针的储存的值，也就是 t 的地址 *pp = p = &t *pp = 0x7ffeea82499c\n    cout << "**pp = " << **pp << endl << endl; // 一级指针储存地址的值，也就是 t 的值 **pp = 10\n\n    int*** ppp = &pp;\n    cout << "&pp = " << &pp << endl;  // &pp = 0x7ffeea824988\n    cout << "&ppp = " << &ppp << endl; // &ppp = 0x7ffeea824980\n    cout << "ppp = " << ppp << endl; // &pp  ppp = 0x7ffeea824988\n    cout << "*ppp = " << *ppp << endl; // pp = &p  *ppp = 0x7ffeea824990\n    cout << "**ppp = " << **ppp << endl; // p = &t  **ppp = 0x7ffeea82499c\n    cout << "***ppp = " << ***ppp << endl; // t = *p = **pp ***ppp = 10\n\n\n}\n\nint main()\n{\n\tp_LV2();\n    p_LV3();\n}\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);